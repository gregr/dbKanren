#lang racket/base
(provide naive:walk*
         bis:query->stream bis:retrieve
         dfs:query->stream dfs:retrieve)
(require "../stream.rkt" "constraint.rkt" "syntax.rkt"
         (except-in racket/match ==)
         racket/function racket/vector)

(define (bis:query->stream q)
  (match-define `#s(query ,x ,g) q)
  (define (return st) (pretty (naive:walk* st x)))
  (s-map return ((bis:goal g) state.empty)))
(define (bis:bind s k)
  (cond ((null?      s) '())
        ((procedure? s) (thunk (bis:bind (s) k)))
        (else           (bis:mplus (k (car s)) (thunk (bis:bind (cdr s) k))))))
(define (bis:mplus s1 s2)
  (cond ((null?      s1) (s2))
        ((procedure? s1) (thunk (bis:mplus (s2) s1)))
        (else (define d1  (cdr s1))
              (define s1^ (if (procedure? d1) d1 (thunk d1)))
              (cons (car s1) (thunk (bis:mplus (s2) s1^))))))
(define ((bis:retrieve s args) st)
  (let loop ((s (s-next s)))
    (cond ((null?      s) '())
          ((procedure? s) (thunk (loop (s))))
          (else (bis:mplus ((bis:== (car s) args) st)
                           (thunk (loop (s-next (cdr s)))))))))
(define ((bis:apply/expand ex args) st)
  ((bis:goal (apply ex (naive:walk* st args))) st))
(define ((bis:expand ex args) st) ((bis:goal (apply ex args)) st))
(define (bis:goal g)
  (match g
    (`#s(conj ,g1 ,g2) (let ((k1 (bis:goal g1)) (k2 (bis:goal g2)))
                         (lambda (st) (bis:bind (k1 st) k2))))
    (`#s(disj ,g1 ,g2) (let ((k1 (bis:goal g1)) (k2 (bis:goal g2)))
                         (lambda (st) (bis:mplus (k1 st) (thunk (k2 st))))))
    (`#s(==/use ,lhs ,args ,rhs ,desc) (bis:==/use lhs args rhs desc))
    (`#s(constrain ,(? procedure? proc) ,args)
      (define r (relations-ref proc))
      (define apply/bis    (hash-ref r 'apply/bis    #f))
      (define apply/expand (hash-ref r 'apply/expand #f))  ; impure expansion
      (define expand       (hash-ref r 'expand       #f))  ; pure expansion
      (cond (apply/bis    (apply/bis args))
            (apply/expand (bis:apply/expand apply/expand args))
            (expand       (bis:expand       expand       args))
            (else (error "no interpretation for:" proc args))))
    (`#s(constrain (retrieve ,s) ,args)     (bis:retrieve s args))
    (`#s(constrain ==            (,t1 ,t2)) (bis:== t1 t2))))
(define ((bis:== t1 t2) st)
  (let ((st (unify st t1 t2))) (if st (list st) '())))
(define ((bis:==/use lhs args rhs desc) st)
  (define deps (map (naive:use desc st) args))
  ((bis:== lhs (apply rhs deps)) st))

(define (dfs:query->stream q) ((dfs:query q) state.empty))
(define (dfs:query q)
  (match-define `#s(query ,x ,g) q)
  (define (return st) (list (pretty (naive:walk* st x))))
  (dfs:goal g return))
(define ((dfs:mplus k1 k2) st) (s-append (k1 st) (thunk (k2 st))))
(define ((dfs:retrieve s args k) st)
  (let loop ((s (s-next s)))
    (cond ((null?      s) '())
          ((procedure? s) (thunk (loop (s))))
          (else ((dfs:mplus (dfs:==       (car s) args k)
                            (dfs:retrieve (cdr s) args k))
                 st)))))
(define ((dfs:apply/expand ex args k) st)
  ((dfs:goal (apply ex (naive:walk* st args)) k) st))
(define ((dfs:expand ex args k) st) ((dfs:goal (apply ex args) k) st))
(define (dfs:goal g k)
  (define loop dfs:goal)
  (match g
    (`#s(conj ,g1 ,g2) (loop g1 (loop g2 k)))
    (`#s(disj ,g1 ,g2) (dfs:mplus (loop g1 k) (loop g2 k)))
    (`#s(==/use ,lhs ,args ,rhs ,desc) (dfs:==/use lhs args rhs desc k))
    (`#s(constrain ,(? procedure? proc) ,args)
      (define r (relations-ref proc))
      (define apply/dfs    (hash-ref r 'apply/dfs    #f))
      (define apply/expand (hash-ref r 'apply/expand #f))  ; impure expansion
      (define expand       (hash-ref r 'expand       #f))  ; pure expansion
      (cond (apply/dfs    (apply/dfs k args))
            (apply/expand (dfs:apply/expand apply/expand args k))
            (expand       (dfs:expand       expand       args k))
            (else (error "no interpretation for:" proc args))))
    (`#s(constrain (retrieve ,s) ,args)     (dfs:retrieve s args k))
    (`#s(constrain ==            (,t1 ,t2)) (dfs:== t1 t2 k))))
(define ((dfs:== t1 t2 k) st) (let ((st (unify st t1 t2))) (if st (k st) '())))
(define ((dfs:==/use lhs args rhs desc k) st)
  (define deps (map (naive:use desc st) args))
  ((dfs:== lhs (apply rhs deps) k) st))

(define ((naive:use desc st) arg)
  (if (procedure? arg) arg
    (let ((t (naive:walk* st arg)))
      (unless (ground? t) (error ":== dependency is not ground:" t desc))
      t)))

(define (naive:walk* st t)
  (let loop ((term t))
    (define t (walk st term))
    (cond ((pair?   t) (cons (loop (car t)) (loop (cdr t))))
          ((vector? t) (vector-map loop t))
          (else        t))))
