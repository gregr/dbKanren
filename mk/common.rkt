#lang racket/base
(provide booleano symbolo numbero stringo byteso vectoro integero
         not-pairo not-booleano not-symbolo not-numbero not-stringo
         not-byteso not-vectoro not-integero
         vector==listo bytes==listo <=o <o string<=o string<o absento
         appendo membero)
(require "../order.rkt" "syntax.rkt")

(define-relation (booleano t) (conde ((== t #t)) ((== t #f))))
(define-relation (symbolo t)
  (<=anyo term.symbol.min t) (<=anyo t term.symbol.max)
  (=/= t term.symbol.max))
(define-relation (numbero t)
  (<=anyo term.number.min t) (<=anyo t term.number.max)
  (=/= t term.number.min) (=/= t term.number.max))
(define-relation (stringo t)
  (<=anyo term.string.min t) (<=anyo t term.string.max)
  (=/= t term.string.max))
(define-relation (byteso t)
  (<=anyo term.bytes.min t) (<=anyo t term.bytes.max)
  (=/= t term.bytes.max))
(define-relation (vectoro t)
  (<=anyo term.vector.min t) (<=anyo t term.bytes.max)
  (=/= t term.vector.max))
(define-relation (integero t) (flooro t t))

(define-relation (not-pairo t)
  (conde ((<=anyo t term.pair.min) (=/= t term.pair.min))
         ((<=anyo term.pair.max t))))
(define-relation (not-booleano t) (=/= t #t) (=/= t #f))
(define-relation (not-symbolo t)
  (conde ((<=anyo t term.symbol.min) (=/= t term.symbol.min))
         ((<=anyo term.symbol.max t))))
(define-relation (not-numbero t)
  (conde ((<=anyo t term.number.min))
         ((<=anyo term.number.max t))))
(define-relation (not-stringo t)
  (conde ((<=anyo t term.string.min) (=/= t term.string.min))
         ((<=anyo term.string.max t))))
(define-relation (not-byteso t)
  (conde ((<=anyo t term.bytes.min) (=/= t term.bytes.min))
         ((<=anyo term.bytes.max t))))
(define-relation (not-vectoro t)
  (conde ((<=anyo t term.vector.min) (=/= t term.vector.min))
         ((<=anyo term.vector.max t))))
(define-relation (not-integero t) (fresh (x) (flooro t x) (=/= t x)))

;; TODO: /o, %o, quotiento, remaindero?
(define-relation (<=o t1 t2) (numbero t1) (numbero t2) (<=anyo t1 t2))
(define-relation (<o  t1 t2) (<=o t1 t2) (=/= t1 t2))
(define-relation (string<=o t1 t2) (stringo t1) (stringo t2) (<=anyo t1 t2))
(define-relation (string<o  t1 t2) (string<=o t1 t2) (=/= t1 t2))

(define-relation (vector/i==listo i t1 t2)
  (fresh (len x xs i+1)
    (vector-lengtho t1 len)
    (conde ((== t2 '()) (== i len))
           ((== t2 `(,x . ,xs))
            (<o i len)
            (+o i 1 i+1)
            (vector-refo t1 i x)
            (vector/i==listo i+1 t1 xs)))))
(define-relation (vector==listo t1 t2) (vector/i==listo 0 t1 t2))

(define-relation (bytes/i==listo i t1 t2)
  (fresh (len x xs i+1)
    (bytes-lengtho t1 len)
    (conde ((== t2 '()) (== i len))
           ((== t2 `(,x . ,xs))
            (<o i len)
            (+o i 1 i+1)
            (bytes-refo t1 i x)
            (bytes/i==listo i+1 t1 xs)))))
(define-relation (bytes==listo t1 t2) (bytes/i==listo 0 t1 t2))

(define-relation (absent-vectoro x v i)
  (fresh (len element i+1)
    (vector-lengtho v len)
    (conde ((== i len))
           ((<o i len)
            (+o i 1 i+1)
            (vector-refo v i element)
            (absento x element)
            (absent-vectoro x v i+1)))))
(define-relation (absento x t)
  (=/= x t)
  (conde ((fresh (a d)
            (== t `(,a . ,d))
            (absento x a)
            (absento x d)))
         ((absent-vectoro x t 0))
         ((not-pairo t) (not-vectoro t))))

(define-relation (appendo xs ys xsys)
  (conde ((== xs '()) (== ys xsys))
         ((fresh (a d res)
            (== `(,a . ,d)   xs)
            (== `(,a . ,res) xsys)
            (appendo d ys res)))))

(define-relation (membero x xs)
  (fresh (a d)
    (== xs `(,a . ,d))
    (conde ((== x a))
           ((membero x d)))))
