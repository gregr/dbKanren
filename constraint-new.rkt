#lang racket/base
(provide ;bis:query->stream dfs:query->stream
         ;materialized-relation define-materialized-relation
         ;relation/stream letrec-relation/stream define-relation/stream
         )
(require "method.rkt" "order.rkt" "record.rkt" "stream.rkt" "syntax.rkt"
         "table.rkt" (except-in racket/match ==)
         racket/function racket/list racket/set racket/vector)

(define (foldl/and f acc xs . yss)
  (let loop ((acc acc) (xs xs) (yss yss))
    (if (null? xs)
      acc
      (and acc (loop (apply f (car xs) (append (map car yss) (list acc)))
                     (cdr xs)
                     (map cdr yss))))))
(define-syntax let*/and
  (syntax-rules ()
    ((_ () body ...)                   (let () body ...))
    ((_ ((lhs rhs) rest ...) body ...) (let ((lhs rhs))
                                         (and lhs (let*/and (rest ...)
                                                    body ...))))))

(define (uid:new) (gensym))

;; Interval bounds for describing a (potentially-infinite) set of terms
(struct bounds (lb lb-inclusive? ub ub-inclusive?) #:prefab)
(define bounds.any (bounds term.min #t term.max #t))

(define (term-bounds st t.0)
  (define t (walk st t.0))
  (cond ((pair? t)
         (define b.a (term-bounds st (car t)))
         (define b.d (term-bounds st (cdr t)))
         (apply bounds
                (append
                  (if (bounds-lb-inclusive? b.a)
                    (list (cons (bounds-lb b.a) (bounds-lb b.d)) (bounds-lb-inclusive? b.d))
                    (list (cons (bounds-lb b.a) term.max)        #f))
                  (if (bounds-ub-inclusive? b.a)
                    (list (cons (bounds-ub b.a) (bounds-ub b.d)) (bounds-ub-inclusive? b.d))
                    (list (cons (bounds-ub b.a) term.min)        #f)))))
        ((vector? t)
         (define b (term-bounds st (vector->list t)))
         (bounds (list->vector (bounds-lb b)) (bounds-lb-inclusive? b)
                 (list->vector (bounds-ub b)) (bounds-ub-inclusive? b)))
        ((var? t) (vcx-bounds (state-vcx-ref st t)))
        (else     (bounds t #t t #t))))

;; Variable constraints
(record vcx (bounds simple table disj))
(define vcx.empty (vcx (bounds bounds.any) (simple (set)) (table (set)) (disj (set))))

(define (vcx-bounds-set  x b) (vcx:set x (bounds b)))
(define (vcx-simple-add  x c) (vcx:set x (simple (set-add (vcx-simple x) c))))
(define (vcx-table-clear x)   (vcx:set x (table  (set))))
(define (vcx-table-add   x c) (vcx:set x (table  (set-add (vcx-table  x) c))))
(define (vcx-disj-clear  x)   (vcx:set x (disj   (set))))
(define (vcx-disj-add    x c) (vcx:set x (disj   (set-add (vcx-disj   x) c))))

;; Work queue with recency-based prioritization
(struct queue (recent high low))
(define queue.empty (queue (set) '() '()))

;; Partially-satisfied state of a query's constraints
(record state (qterm vars log var=>cx cx pending))
(define (state:new qterm) (state (qterm qterm) (vars (term-vars qterm)) (log '())
                                 (var=>cx (hash)) (cx (hash)) (pending queue.empty)))

(define (state-vars-simplify st)
  (state:set st (vars (term-vars (walk* st (set->list (state-vars st)))))))

(define (state-vcx-ref st x)                          (hash-ref (state-var=>cx st) x vcx.empty))
(define (state-vcx-set st x t) (state:set st (var=>cx (hash-set (state-var=>cx st) x t))))

(define (state-log-add st c)
  (define log (state-log st))
  (state:set st (log (and log (cons c log)))))

(define (state-cx-add st vars vcx-add uid? c)
  (if (null? vars)
    (state-log-add st c)
    (let ((uid (or uid? (uid:new))))
      (foldl (lambda (x st)
               (state-vcx-set st x (vcx-add (state-vcx-ref st x) uid)))
             (state:set (state-log-add st c)
                        (cx (hash-set (state-cx st) uid c)))
             vars))))

(define (state-cx-update* st uids)
  (define uid=>c (state-cx st))
  (define c* (map (lambda (uid) (hash-ref uid=>c uid #f)) uids))
  (foldl/and (lambda (uid c st) (c-apply st uid c))
             (state:set st (cx (foldl (lambda (uid uid=>c) (hash-remove uid=>c uid))
                                      (state-cx st) uids)))
             uids c*))

(define (state-uses-empty?! st)
  (define uses (filter c:use? (hash-values (state-cx st))))
  (unless (null? uses)
    (error ":== dependencies are not ground:"
           (map (lambda (u)
                  (match-define `#s(c:use ,vs ,l ,deps ,r ,desc) u)
                  (pretty (==/use (walk* st l) (walk* st deps) r desc))
                  (error ":== dependencies are not ground:"
                         (pretty (==/use (walk* st l) (walk* st deps) r desc))))
                uses))))

(define (state-solve-lte-cycles st)
  (define cs (map (lambda (c)
                    (match-define (c:<= lhs rhs) c)
                    (c:<= (walk* st lhs) (walk* st rhs)))
                  (filter c:<=? (hash-values (state-cx st)))))
  ;; Kosaraju's algorithm for simplicity
  (define a<=b (foldl (lambda (c a<=b)
                        (match-define (c:<= lhs rhs) c)
                        (hash-update a<=b lhs (lambda (rhss) (cons rhs rhss)) '()))
                      (hash) cs))
  (define b>=a (foldl (lambda (c b>=a)
                        (match-define (c:<= lhs rhs) c)
                        (hash-update b>=a rhs (lambda (lhss) (cons lhs lhss)) '()))
                      (hash) cs))
  (define (dfs graph pending.0 order.0 source)
    (cond ((set-member? source pending.0)
           (match-define (cons pending order)
             (foldl (lambda (target p&o)
                      (match-define (cons p o) p&o)
                      (dfs graph p o target))
                    (cons (set-remove pending.0 source) order.0)
                    (hash-ref graph source)))
           (cons pending (cons source order)))
          (else (cons pending order))))
  (define order.<=
    (let loop ((pending (list->set (hash-keys a<=b))) (order '()))
      (if (set-empty? pending)
        order
        (match-let (((cons pending order) (dfs a<=b pending order (set-first pending))))
          (loop pending order)))))
  (define sccs
    (let loop ((order order.<=) (pending (list->set (hash-keys b>=a))))
      (if (null? order)
        '()
        (match-let (((cons pending scc) (dfs b>=a pending '() (car order))))
          (cons scc (loop (cdr order) pending))))))
  (foldl/and (lambda (scc st)
               (define t.0 (car scc))
               (foldl/and (lambda (t st) (unify st t t.0)) st (cdr scc)))
             st sccs))

(define (state-schedule-add st x)
  (define (st/q recent high low) (state:set st (pending (queue recent high low))))
  (match-define (queue recent high low) (state-pending st))
  (cond ((or (member x high)
             (member x low))    st)
        ((set-member? recent x) (st/q          recent            high (cons x low)))
        (else                   (st/q (set-add recent x) (cons x high)        low))))

(define (state-schedule-run st)
  (define (update-and-loop st x)
    (define t (walk st x))
    (let*/and ((st (if (var? t) (var-update st t) st)))
      (state-schedule-run st)))
  (match-define (queue recent high low) (state-pending st))
  (cond ((not (null? high)) (update-and-loop
                              (state:set st (pending (queue recent (cdr high)     low)))
                              (car high)))
        ((not (null? low))  (define high.new (reverse low))
                            (update-and-loop
                              (state:set st (pending (queue recent (cdr high.new) '())))
                              (car high.new)))
        (else               (state:set st (pending queue.empty)))))

(define (state-enforce-local-consistency st)
  (let*/and ((st (state-schedule-run     st))
             (st (state-solve-lte-cycles st)))
    (if (set-empty? (queue-recent (state-pending st)))
      st
      (state-enforce-local-consistency st))))

;; Internal constraint algebra
(struct c:conj  (cs)                              #:prefab)
(struct c:disj  (cs)                              #:prefab)
(struct c:==    (l r)                             #:prefab)
(struct c:=/=   (l r)                             #:prefab)
(struct c:<=    (l r)                             #:prefab)
(struct c:use   (vars.pending lhs args proc desc) #:prefab)
;; TODO: store args and v=>i* directly in t controller?
(struct c:table (t args v=>i*)                    #:prefab)
(struct c:proc  (proc args parents)               #:prefab)

(define (f->c f)
  (match f
    (`#s(==/use ,lhs ,args ,proc ,desc) (c:use args lhs args proc desc))
    (`#s(conj ,f1 ,f2) (define (f->cs f) (match (f->c f)
                                           ((c:conj cs) cs)
                                           (c           (list c))))
                       (c:conj (append (f->cs f1) (f->cs f2))))
    (`#s(disj ,f1 ,f2) (define (f->cs f) (match (f->c f)
                                           ((c:disj cs) cs)
                                           (c           (list c))))
                       (c:disj (append (f->cs f1) (f->cs f2))))
    (`#s(constrain =/=    (,lhs ,rhs))  (c:=/= lhs rhs))
    (`#s(constrain ==     (,lhs ,rhs))  (c:==  lhs rhs))
    (`#s(constrain any<=o (,lhs ,rhs))  (c:<=  lhs rhs))
    ;; TODO: table and procedure constraints
    ))

;; TODO: choosing/enumerating table and disjunction search space

(define (c-success? c) (and (c:conj? c) (null? (c:conj-cs c))))

(define (c-simplify st c)
  (let*/and ((st (c-apply #f (state:set st (log '())) c))
             (st (state-enforce-local-consistency st)))
    (let ((log (state-log st)))
      (if (and (pair? log) (null? (cdr log)))
        (car log)
        (c:conj log)))))

(define (c-apply st uid? c)
  (match c
    ((c:==  l r) (unify    st      l r))
    ((c:=/= l r) (disunify st uid? l r))
    ((c:<=  l r) (ltunify  st uid? l r))
    ((c:disj cs) (disjoin  st uid? cs))
    ((c:conj cs) (conjoin  st      cs))
    ((c:use vars.pending lhs args proc desc)
     (use st uid? vars.pending lhs args proc desc))
    ;; TODO: table and procedure constraints
    ))

(define (unify st t1 t2)
  (let ((t1 (walk st t1)) (t2 (walk st t2)))
    (cond ((eqv? t1 t2) st)
          ((var?    t1) (var-assign st t1 t2))
          ((var?    t2) (var-assign st t2 t1))
          ((pair?   t1) (and (pair? t2)
                             (let ((st (unify st (car t1) (car t2))))
                               (and st (unify st (cdr t1) (cdr t2))))))
          ((vector? t1) (and (vector? t2) (= (vector-length t1)
                                             (vector-length t2))
                             (unify st (vector->list t1) (vector->list t2))))
          ((string? t1) (and (string? t2) (string=? t1 t2) st))
          ((bytes?  t1) (and (bytes?  t2) (bytes=?  t1 t2) st))
          (else         #f))))

(define (disunify st uid? t1 t2)
  (let ((t1 (walk st t1)) (t2 (walk st t2)))
    (cond ((eqv? t1 t2) #f)
          ((var?    t1) (var-disassign st uid? t1 t2))
          ((var?    t2) (var-disassign st uid? t2 t1))
          ((pair?   t1) (cond ((not (pair? t2)) st)
                              (else (disjoin st #f (list (c:=/= (car t1) (car t2))
                                                         (c:=/= (cdr t1) (cdr t2)))))))
          ((vector? t1) (cond ((not (and (vector? t2))
                                    (= (vector-length t1) (vector-length t2))) st)
                              (else (disjoin st #f (map c:=/=
                                                        (vector->list t1)
                                                        (vector->list t2))))))
          (else         st))))

(define (ltunify st uid? t1 t2)
  (let ((t1 (walk st t1)) (t2 (walk st t2)))
    (cond ((or (null? t1) (eq? #t t2)) st)
          ((or (var? t1) (var? t2))
           (match-define (bounds lb.t1 lbi.t1 ub.t1 ubi.t1) (term-bounds st t1))
           (match-define (bounds lb.t2 lbi.t2 ub.t2 ubi.t2) (term-bounds st t2))
           (cond ((any<=?                                ub.t1 lb.t2) st)
                 (((if (and lbi.t1 ubi.t2) any<? any<=?) ub.t2 lb.t1) #f)
                 (else (let*/and
                         ((st (cond ((not (var? t1))
                                     ;; update any vars embedded in t1
                                     (let*/and ((st (ltunify st #f t1 ub.t2)))
                                       (if (not ubi.t2)
                                         (disunify st #f t1 ub.t2)
                                         st)))
                                    ((or (any<? ub.t2 ub.t1)
                                         (and ubi.t1 (not ubi.t2) (equal? ub.t2 ub.t1)))
                                     (var-assign-bounds
                                       st t1 (bounds lb.t1 lbi.t1 ub.t2 ubi.t2)))
                                    (else st)))
                          (st (cond ((not (var? t2))
                                     ;; update any vars embedded in t2
                                     (let*/and ((st (ltunify st #f lb.t1 t2)))
                                       (if (not lbi.t1)
                                         (disunify st #f lb.t1 t2)
                                         st)))
                                    ((or (any<? lb.t2 lb.t1)
                                         (and (not lbi.t1) lbi.t2 (equal? lb.t2 lb.t1)))
                                     (var-assign-bounds
                                       st t2 (bounds lb.t1 lbi.t1 ub.t2 ubi.t2)))
                                    (else st))))
                         (let* ((t1    (walk* st t1))
                                (t2    (walk* st t2))
                                (vs.t1 (term-vars t1))
                                (vs.t2 (term-vars t2))
                                (vs    (if (or (set-empty? vs.t1) (set-empty? vs.t2))
                                         '()
                                         (set->list (set-union vs.t1 vs.t2)))))
                           (state-cx-add st vs vcx-simple-add uid? (c:<= t1 t2)))))))
          ((pair? t1)
           (cond ((pair?   t2) (let*/and ((st (ltunify st #f (car t1) (car t2))))
                                 (disjoin st #f (list (c:=/= (car t1) (car t2))
                                                      (c:<=  (cdr t1) (cdr t2))))))
                 ((vector? t2)                        st)
                 (else (and (any<=? term.pair.max t2) st))))
          ((vector? t1)
           (cond ((vector? t2)
                  (define len.t1 (vector-length t1))
                  (define len.t2 (vector-length t2))
                  (cond ((< len.t1 len.t2) st)
                        ((> len.t1 len.t2) #f)
                        (else (ltunify st #f (vector->list t1) (vector->list t2)))))
                 ((pair? t2)                            #f)
                 (else (and (any<=? term.vector.max t2) st))))
          (else (and (any<=? t1 t2) st)))))

(define (disjoin st uid? cs)
  (define (c-vars c)
    (match c
      ((c:==  l r)        (set-union (term-vars l)     (term-vars r)))
      ((c:=/= l r)        (set-union (term-vars l)     (term-vars r)))
      ((c:<=  l r)        (set-union (term-vars l)     (term-vars r)))
      ((c:disj cs)        (set-union (c-vars (car cs)) (c-vars (cadr cs))))
      ((c:conj cs)        (apply set-union (map c-vars cs)))
      ((c:use vs _ _ _ _) (term-vars vs))
      ;; TODO: table and procedure constraints
      ))
  (let loop ((cs cs) (cs.new '()))
    (if (null? cs)
      (match cs.new
        ('()          #f)
        ((list c.new) (c-apply st #f c.new))
        (_            (define cx (c:disj (reverse cs.new)))
                      (state-cx-add st (c-vars cx) vcx-disj-add uid? cx)))
      (match (c-simplify st (car cs))
        (#f            (loop (cdr cs) cs.new))
        ((c:conj '())  st)
        ((c:disj cs.d) (loop (cdr cs) (foldl cons cs.new cs.d)))
        (c             (loop (cdr cs) (cons c cs.new)))))))

(define (conjoin st cs) (foldl/and (lambda (c st) (c-apply st #f c)) st cs))

(define (use st uid? t.vs lhs args proc desc)
  ;; TODO: performance
  ;; * can interleave walk* and term-vars
  (define vars.pending (set->list (term-vars (walk* st t.vs))))
  (if (null? vars.pending)
    (unify st lhs (apply proc (walk* st args)))
    (state-cx-add st vars.pending vcx-simple-add uid?
                  `#s(c:use ,vars.pending ,lhs ,args ,proc ,desc))))

(define (var-update st x)
  (define vcx.x (state-vcx-ref st x))
  (foldl/and (lambda (uids st) (state-cx-update* st uids))
             (list (vcx-table  vcx.x)  ;; typically the strongest constraints
                   (vcx-simple vcx.x)
                   (vcx-disj   vcx.x))))

(define (var-assign st x t)
  ;; could replace occurs check with: (set-member? (term-vars (walk* st t)) x)
  (and (not (let occurs? ((t t))
              (cond ((pair?   t) (or (occurs? (walk st (car t)))
                                     (occurs? (walk st (cdr t)))))
                    ((vector? t) (let vloop ((i (- (vector-length t) 1)))
                                   (and (<= 0 i) (or (occurs? (walk st (vector-ref t i)))
                                                     (vloop (- i 1))))))
                    (else        (eq? x t)))))
       (let* ((vcx.x              (state-vcx-ref st x))
              (vcx.t (if (var? t) (state-vcx-ref st t) vcx.empty))
              (st    (state-log-add st (c:== x t)))
              (st    (state-vcx-set st x t)))
         (match-define (bounds lb lbi ub ubi) (vcx-bounds vcx.x))
         (foldl/and (lambda (uids st) (state-cx-update* st uids))
                    (c-apply st #f (c:conj (append (list (c:<= lb t) (c:<= t ub))
                                                   (if lbi '() (list (c:=/= lb t)))
                                                   (if ubi '() (list (c:=/= t ub))))))
                    (list (vcx-simple vcx.x)  ;; the least expensive constraints
                          (vcx-table  vcx.x)
                          (vcx-disj   vcx.x))))))

(define (var-disassign st uid? x t)
  (let* ((t    (walk* st t))
         (vs.t (term-vars t)))
    (define (add) (state-cx-add st (set->list vs.t) vcx-simple-add uid? (c:=/= x t)))
    (cond ((set-member? vs.t x) st)  ;; simple occurs check
          ((set-empty?  vs.t)
           (match-define (bounds lb lbi ub ubi) (term-bounds st x))
           (define (assign-bounds c b) (var-assign-bounds (state-log-add st c) x b))
           (cond ((and lbi (equal? t lb)) (define lb.inc (any-increment lb))
                                          (if (eq? lb lb.inc)
                                            (assign-bounds (c:=/= lb     x) (bounds lb     #f ub ubi))
                                            (assign-bounds (c:<=  lb.inc x) (bounds lb.inc #t ub ubi))))
                 ((and ubi (equal? t ub)) (define ub.dec (any-decrement ub))
                                          (if (eq? ub ub.dec)
                                            (assign-bounds (c:=/= x ub    ) (bounds lb lbi ub     #f))
                                            (assign-bounds (c:<=  x ub.dec) (bounds lb lbi ub.dec #t))))
                 ((or (any<=? t lb) (any<=? ub t)) st)
                 (else                             (add))))
          (else (match-define (bounds lb.x lbi.x ub.x ubi.x) (term-bounds st x))
                (match-define (bounds lb.t lbi.t ub.t ubi.t) (term-bounds st t))
                (if (or ((if (and lbi.t ubi.x) any<? any<=?) ub.x lb.t)
                        ((if (and ubi.t lbi.x) any<? any<=?) ub.t lb.x))
                  st
                  (add))))))

(define (var-assign-bounds st x b)
  (match-define (bounds lb lbi ub ubi) b)
  (cond ((any<?  ub lb) #f)
        ((equal? ub lb) (and lbi ubi (var-assign st x lb)))
        (else (define vcx.new (vcx-bounds-set (state-vcx-ref st x) b))
              (define st.new  (state-schedule-add (state-vcx-set st x vcx.new) x))
              (define domain? (and lbi ubi (finite-interval? lb ub)))
              (if domain?
                ;; TODO: instead, produce a table constraint for efficiency?
                (disjoin st.new #f (map (lambda (t) (c:== x t)) domain?))
                st.new))))

(define (walk st t)
  (if (var? t)
    (let ((v=>cx (state-var=>cx st)))
      (let loop ((x t))
        (define val (hash-ref v=>cx x vcx.empty))
        (cond ((var? val) (loop val))
              ((vcx? val) x)
              (else       val))))
    t))
(define (walk* st t)
  (let loop ((term t))
    (define t (walk st term))
    (cond ((pair?   t) (cons (loop (car t)) (loop (cdr t))))
          ((vector? t) (vector-map loop t))
          (else        t))))

(define (reify st)
  (define term (state-qterm st))
  (define t.0  (walk* st term))
  ;; TODO: reify both =/= and <= constraints
  (pretty t.0))
