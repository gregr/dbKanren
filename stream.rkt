#lang racket/base
(provide s-next s-force s-split s-take s-drop s-append s-filter s-map s-each
         s-fold s-scan s-group s-memo s-enumerate s-dedup)
(require racket/function)

(define (s-next  s) (if (procedure? s)          (s)  s))
(define (s-force s) (if (procedure? s) (s-force (s)) s))

(define (s-split n s)
  (let loop ((n n) (rxs '()) (s s))
    (if (and n (= n 0)) (cons (reverse rxs) s)
      (let ((s (s-force s)))
        (if (null? s) (cons (reverse rxs) s)
          (loop (and n (- n 1)) (cons (car s) rxs) (cdr s)))))))

(define (s-take n s)
  (if (and n (= n 0)) '()
    (let ((s (s-force s)))
      (if (null? s) '() (cons (car s) (s-take (and n (- n 1)) (cdr s)))))))

(define (s-drop n s)
  (if (= n 0) s (let ((s (s-force s)))
                  (if (null? s) '() (s-drop (- n 1) (cdr s))))))

(define (s-append a b)
  (cond ((null? a) b)
        ((pair? a) (cons (car a) (s-append (cdr a) b)))
        (else      (thunk        (s-append     (a) b)))))

(define (s-filter ? s)
  (cond ((null? s)      '())
        ((procedure? s) (thunk        (s-filter ?     (s))))
        ((? (car s))    (cons (car s) (s-filter ? (cdr s))))
        (else                         (s-filter ? (cdr s)))))

(define (s-map f s . ss)
  (cond ((null? s)      '())
        ((procedure? s) (thunk (apply s-map f (s) ss)))
        ((pair? s) (let loop ((ss-pending ss) (rss '()))
                     (if (null? ss-pending)
                       (let ((ss (reverse rss)))
                         (cons (apply f (car s) (map car ss))
                               (apply s-map f (cdr s) (map cdr ss))))
                       (let next ((ss0 (car ss-pending)))
                         (if (procedure? ss0) (thunk (next (ss0)))
                           (loop (cdr ss-pending) (cons ss0 rss)))))))))

(define (s-each p s) (let ((s (s-force s)))
                       (unless (null? s) (p (car s)) (s-each p (cdr s)))))

(define (s-fold n s acc f)
  (if (and n (= n 0)) (cons acc s)
    (let ((s (s-force s)))
      (if (null? s) (list acc)
        (s-fold (and n (- n 1)) (cdr s) (f (car s) acc) f)))))

(define (s-scan s acc f)
  (cons acc (cond ((null? s)      '())
                  ((pair? s)      (s-scan (cdr s) (f (car s) acc) f))
                  ((procedure? s) (thunk (s-scan (s) acc f))))))

(define (s-group s ? @)
  (let ((@ (or @ (lambda (x) x))))
    (cond ((null? s)      '())
          ((procedure? s) (thunk (s-group (s) ? @)))
          (else (let next ((x (@ (car s))) (s s))
                  (let loop ((g (list (car s))) (s (cdr s)))
                    (cond ((null? s)      (list g))
                          ((procedure? s) (thunk (loop g (s))))
                          (else (let ((y (@ (car s))))
                                  (if (? y x) (loop (cons (car s) g) (cdr s))
                                    (cons g (next y s))))))))))))

(define (s-memo s)
  (cond ((procedure? s) (let ((v #f) (s s))
                          (thunk (when s (set! v (s-memo (s))) (set! s #f))
                                 v)))
        ((null? s)      '())
        (else           (cons (car s) (s-memo (cdr s))))))

(define (s-enumerate i s)
  (cond ((null? s) '())
        ((pair? s) (cons (cons i (car s)) (s-enumerate (+ i 1) (cdr s))))
        (else      (thunk                 (s-enumerate i           (s))))))

;; NOTE: only adjacent duplicates are removed
(define (s-dedup s)
  (define (loop x s)
    (cond ((null? s) (list x))
          ((pair? s) (if (equal? x (car s)) (loop x (cdr s))
                       (cons x (loop (car s) (cdr s)))))
          (else      (thunk (loop x (s))))))
  (cond ((null? s) '())
        ((pair? s) (loop (car s) (cdr s)))
        (else      (thunk (s-dedup (s))))))
