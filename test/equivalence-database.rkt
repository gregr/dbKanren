#lang racket/base
(provide build-equivalence-database)
(require
  racket/unsafe/ops
  ;"../dbk/safe-unsafe.rkt"
  "../dbk/database.rkt" racket/fixnum)

(define name.equiv-edge         'equivalence-edge)
(define name.equiv-class-member 'equivalence-class-member)

;; NOTE: for best performance, the left node of each edge should be the alphabetically smaller text
(define (build-equivalence-database path en.edge*)
  (define db.equiv (database path))
  (unless (or (database-relation-name? db.equiv name.equiv-edge)
              (database-relation-name? db.equiv name.equiv-class-member))
    (let ((r.equiv-edge (build-enumerator-relation db.equiv '(text text) en.edge*)))
      (relation-name-set! r.equiv-edge name.equiv-edge)
      (relation-attributes-set! r.equiv-edge '(A B))
      (database-commit! db.equiv)))
  (let ((r.equiv-edge (database-relation db.equiv name.equiv-edge)))
    (relation-full-compact! r.equiv-edge)
    (relation-index-add! r.equiv-edge '(A B))
    (database-commit! db.equiv)
    (unless (database-relation-name? db.equiv name.equiv-class-member)
      (let-values (((text=>id id=>text) (relation-text-dicts r.equiv-edge #f)))
        (let* ((A=>B=>1   (relation-index-dict r.equiv-edge '(A B) #f))
               (count.id* (dict-count id=>text))
               (id=>id    (make-fxvector count.id*)))
          (define (walk i)
            (let loop ((id.child i))
              (let ((id.parent (unsafe-fxvector-ref id=>id id.child)))
                (if (unsafe-fx= id.parent id.child)
                    id.child
                    (let ((id.top (loop id.parent)))
                      (unless (unsafe-fx= id.top id.parent)
                        (unsafe-fxvector-set! id=>id id.child id.top))
                      id.top)))))
          (range-for-each (lambda (i) (unsafe-fxvector-set! id=>id i i)) count.id*)
          ((dict-enumerator A=>B=>1)
           (lambda (id.A B=>1)
             (let ((current (walk id.A)))
               (define (unify! candidate)
                 (let ((candidate (walk candidate)))
                   (cond ((unsafe-fx< candidate current) (unsafe-fxvector-set! id=>id current candidate)
                                                         (set! current candidate))
                         (else (unsafe-fxvector-set! id=>id candidate current)))))
               ((dict-key-enumerator B=>1) (lambda (id.B) (unify! id.B))))))
          (range-for-each walk count.id*)  ; walk performs path compression
          (let ((r.equiv-class-member
                  (build-enumerator-relation
                    db.equiv '(text text)
                    (let ((id->text (lambda (id)
                                      (dict-ref id=>text id (lambda (v) v)
                                                (lambda () (error "invalid text id" id))))))
                      (lambda (yield)
                        (let loop ((i 0))
                          (when (< i count.id*)
                            (yield (list (id->text (unsafe-fxvector-ref id=>id i))
                                         (id->text i)))
                            (loop (unsafe-fx+ i 1)))))))))
            (relation-name-set! r.equiv-class-member name.equiv-class-member)
            (relation-attributes-set! r.equiv-class-member '(representative member))
            (relation-delete! r.equiv-edge)
            (database-commit! db.equiv)))))
    (let ((r.equiv-class-member (database-relation db.equiv name.equiv-class-member)))
      (relation-full-compact! r.equiv-class-member)
      (relation-index-add! r.equiv-class-member '(representative member) '(member representative))
      (database-commit! db.equiv))
    (database-trash-empty! db.equiv)
    db.equiv))

(define (range-for-each p count)
  (let loop ((i 0)) (when (< i count) (p i) (loop (unsafe-fx+ i 1)))))
