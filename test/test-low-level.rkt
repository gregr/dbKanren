#lang racket/base
(provide
  query:Known->Known
  query:Known->X
  query:X->Known
  query:Known<-X->Known
  query:Known->X->Known
  query:X->Y->Known
  query:Concept
  concept-properties
  concept-property-values
  curie->properties
  edge-properties
  edge-property-values
  edge-id->properties)
(require "../dbk/database.rkt" "../dbk/enumerator.rkt" "../dbk/stream.rkt"
         racket/fixnum racket/match racket/pretty racket/runtime-path racket/set)

;; Control whether data is preloaded from disk and kept in-memory.
;; NOTE: without preloading, thread-safety is not guaranteed by default.
(define preload-index? #f)

(define str.predicate "predicate")
;(define str.predicate "edge_label")

(define (dict-get d key)
  (dict-ref d key (lambda (v) v) (lambda () (error "dict-get failed" key))))

(define (string*->id=>1 str*) (bytes*->id=>1 (map string->bytes/utf-8 str*)))
(define (bytes*->id=>1 text*)
  (let* ((text* (sort (set->list (list->set text*)) bytes<?))
         (id*   (list->vector (map text->id text*))))
    (dict:ref (lambda (i) (vector-ref id* i)) fx<
              (lambda (_) '()) 0 (vector-length id*))))

(define (string->id str) (text->id (string->bytes/utf-8 str)))
(define (id->string id)  (bytes->string/utf-8 (id->text id)))
(define (text->id   b)   (initialize-text!) (dict-get (thread-cell-ref tcell.text=>id) b))
(define (id->text   id)  (initialize-text!) (dict-get (thread-cell-ref tcell.id=>text) id))

(define (concept-properties)          (map id->string (enumerator->list
                                                        (dict-key-enumerator ckey=>cvalue=>curie=>1))))
(define (edge-properties)             (map id->string (enumerator->list
                                                        (dict-key-enumerator ekey=>evalue=>eid=>1))))
(define (concept-property-values key) (s-map id->string (enumerator->s
                                                          (dict-key-enumerator
                                                            (dict-get ckey=>cvalue=>curie=>1
                                                                      (string->id key))))))
(define (edge-property-values    key) (s-map id->string (enumerator->s
                                                          (dict-key-enumerator
                                                            (dict-get ekey=>evalue=>eid=>1
                                                                      (string->id key))))))
(define (curie->properties curie)
  (enumerator->list
    (lambda (yield)
      ((dict-enumerator (dict-get curie=>ckey=>cvalue=>1 (string->id curie)))
       (lambda (ckey cvalue=>1)
         (yield (map id->string (cons ckey (enumerator->list
                                             (dict-key-enumerator cvalue=>1))))))))))
(define (edge-id->properties eid)
  (enumerator->list
    (lambda (yield)
      ((dict-enumerator (dict-get eid=>ekey=>evalue=>1 eid))
       (lambda (ekey evalue=>1)
         (yield (map id->string (cons ekey (enumerator->list
                                             (dict-key-enumerator evalue=>1))))))))))

;; query:Known->X is analogous to a miniKanren-style query with this shape:
; (run* (s sname p o oname)
;   (fresh (id category)
;     (edge id s o)
;     (cprop o "category" category)
;     (cprop s "name" sname)
;     (cprop o "name" oname)
;     (eprop id "predicate" p)
;     (membero s subject-curies)
;     (membero p predicates)
;     (membero category object-categories)))

(define (query:Known->X curie*.K predicate*.K->X category*.X)
  (define (query. yield)
    (let* ((ekey.predicate (string->id str.predicate))
           (ckey.name      (string->id "name"))
           (K=>1           (string*->id=>1 curie*.K)))
      ((merge-join fx< K=>1 subject=>object=>eid=>1)
       (lambda (id.K __ X=>eid=>1)
         (let* ((id.name.K (dict-min (dict-get (dict-get curie=>ckey=>cvalue=>1 id.K) ckey.name)))
                (name.K    (id->string id.name.K))
                (K         (id->string id.K)))
           ((merge-join fx< X=>eid=>1 curie=>ckey=>cvalue=>1)
            (lambda (id.X eid=>1 ckey=>cvalue=>1)
              (let* ((id.name.X (dict-min (dict-get ckey=>cvalue=>1 ckey.name)))
                     (name.X    (id->string id.name.X))
                     (X         (id->string id.X)))
                ((dict-key-enumerator eid=>1)
                 (lambda (eid)
                   (let ((predicate.K->X
                           (id->string (dict-min (dict-get (dict-get eid=>ekey=>evalue=>1 eid)
                                                           ekey.predicate)))))
                     (yield (list* K name.K predicate.K->X X name.X
                                   (edge-id->properties eid))))))))))))))
  (define (query.c yield)
    (let* ((ekey.predicate     (string->id str.predicate))
           (ckey.category      (string->id "category"))
           (ckey.name          (string->id "name"))
           (K=>1               (string*->id=>1 curie*.K))
           (category=>1        (string*->id=>1 category*.X))
           (category=>curie=>1 (dict-get ckey=>cvalue=>curie=>1 ckey.category)))
      ((merge-join fx< K=>1 subject=>object=>eid=>1)
       (lambda (id.K __ X=>eid=>1)
         (let* ((id.name.K (dict-min (dict-get (dict-get curie=>ckey=>cvalue=>1 id.K) ckey.name)))
                (name.K    (id->string id.name.K))
                (K         (id->string id.K)))
           ((merge-join fx< category=>1 category=>curie=>1)
            (lambda (__ ___ X=>1.cprop)
              ((merge-join fx< X=>eid=>1 X=>1.cprop)
               (lambda (id.X eid=>1 __)
                 (let* ((id.name.X (dict-min (dict-get (dict-get curie=>ckey=>cvalue=>1 id.X)
                                                       ckey.name)))
                        (name.X    (id->string id.name.X))
                        (X         (id->string id.X)))
                   ((dict-key-enumerator eid=>1)
                    (lambda (eid)
                      (let ((predicate.K->X
                              (id->string (dict-min (dict-get (dict-get eid=>ekey=>evalue=>1 eid)
                                                              ekey.predicate)))))
                        (yield (list* K name.K predicate.K->X X name.X
                                      (edge-id->properties eid))))))))))))))))
  (define (query.p yield)
    (let* ((ekey.predicate     (string->id str.predicate))
           (ckey.name          (string->id "name"))
           (K=>1               (string*->id=>1 curie*.K))
           (predicate=>1       (string*->id=>1 predicate*.K->X))
           (predicate=>eid=>1  (dict-get ekey=>evalue=>eid=>1 ekey.predicate)))
      ((merge-join fx< K=>1 subject=>eid=>object=>1)
       (lambda (id.K __ eid=>X=>1)
         (let* ((id.name.K (dict-min (dict-get (dict-get curie=>ckey=>cvalue=>1 id.K) ckey.name)))
                (name.K    (id->string id.name.K))
                (K         (id->string id.K)))
           ((merge-join fx< predicate=>1 predicate=>eid=>1)
            (lambda (id.predicate.K->X __ eid=>1)
              (let ((predicate.K->X (id->string id.predicate.K->X)))
                ((merge-join fx< eid=>1 eid=>X=>1)
                 (lambda (eid __ X=>1.edge)
                   ((merge-join fx< X=>1.edge curie=>ckey=>cvalue=>1)
                    (lambda (id.X __ ckey=>cvalue=>1)
                      (let* ((id.name.X (dict-min (dict-get ckey=>cvalue=>1 ckey.name)))
                             (name.X    (id->string id.name.X))
                             (X         (id->string id.X)))
                        (yield (list* K name.K predicate.K->X X name.X
                                      (edge-id->properties eid))))))))))))))))
  (define (query.p&c yield)
    (let* ((ekey.predicate     (string->id str.predicate))
           (ckey.category      (string->id "category"))
           (ckey.name          (string->id "name"))
           (K=>1               (string*->id=>1 curie*.K))
           (predicate=>1       (string*->id=>1 predicate*.K->X))
           (category=>1        (string*->id=>1 category*.X))
           (predicate=>eid=>1  (dict-get ekey=>evalue=>eid=>1   ekey.predicate))
           (category=>curie=>1 (dict-get ckey=>cvalue=>curie=>1 ckey.category)))
      ((merge-join fx< K=>1 subject=>eid=>object=>1)
       (lambda (id.K __ eid=>X=>1)
         (let* ((id.name.K (dict-min (dict-get (dict-get curie=>ckey=>cvalue=>1 id.K) ckey.name)))
                (name.K    (id->string id.name.K))
                (K         (id->string id.K)))
           ((merge-join fx< predicate=>1 predicate=>eid=>1)
            (lambda (id.predicate.K->X __ eid=>1)
              (let ((predicate.K->X (id->string id.predicate.K->X)))
                ((merge-join fx< eid=>1 eid=>X=>1)
                 (lambda (eid __ X=>1.edge)
                   ((merge-join fx< category=>1 category=>curie=>1)
                    (lambda (__ ___ X=>1.cprop)
                      ((dict-join-ordered
                         (lambda (yield)
                           ((merge-join fx< X=>1.cprop X=>1.edge)
                            (lambda (id.X __ ___)
                              (yield id.X '()))))
                         curie=>ckey=>cvalue=>1)
                       (lambda (id.X __ ckey=>cvalue=>1)
                         (let* ((id.name.X (dict-min (dict-get ckey=>cvalue=>1 ckey.name)))
                                (name.X    (id->string id.name.X))
                                (X         (id->string id.X)))
                           (yield (list* K name.K predicate.K->X X name.X
                                         (edge-id->properties eid))))))))))))))))))
  (time (enumerator->rlist (if predicate*.K->X
                               (if category*.X query.p&c query.p)
                               (if category*.X query.c   query.)))))

;; query:X->Known is analogous to a miniKanren-style query with this shape:
; (run* (s sname p o oname)
;   (fresh (id category)
;     (edge id s o)
;     (cprop s "category" category)
;     (cprop s "name" sname)
;     (cprop o "name" oname)
;     (eprop id "predicate" p)
;     (membero o object-curies)
;     (membero p predicates)
;     (membero category subject-categories)))

(define (query:X->Known category*.X predicate*.X->K curie*.K)
  (define (query. yield)
    (let* ((ekey.predicate (string->id str.predicate))
           (ckey.name      (string->id "name"))
           (K=>1           (string*->id=>1 curie*.K)))
      ((merge-join fx< K=>1 object=>subject=>eid=>1)
       (lambda (id.K __ X=>eid=>1)
         (let* ((id.name.K (dict-min (dict-get (dict-get curie=>ckey=>cvalue=>1 id.K) ckey.name)))
                (name.K    (id->string id.name.K))
                (K         (id->string id.K)))
           ((merge-join fx< X=>eid=>1 curie=>ckey=>cvalue=>1)
            (lambda (id.X eid=>1 ckey=>cvalue=>1)
              (let* ((id.name.X (dict-min (dict-get ckey=>cvalue=>1 ckey.name)))
                     (name.X    (id->string id.name.X))
                     (X         (id->string id.X)))
                ((dict-key-enumerator eid=>1)
                 (lambda (eid)
                   (let ((predicate.X->K
                           (id->string (dict-min (dict-get (dict-get eid=>ekey=>evalue=>1 eid)
                                                           ekey.predicate)))))
                     (yield (list* X name.X predicate.X->K K name.K
                                   (edge-id->properties eid))))))))))))))
  (define (query.c yield)
    (let* ((ekey.predicate     (string->id str.predicate))
           (ckey.category      (string->id "category"))
           (ckey.name          (string->id "name"))
           (K=>1               (string*->id=>1 curie*.K))
           (category=>1        (string*->id=>1 category*.X))
           (category=>curie=>1 (dict-get ckey=>cvalue=>curie=>1 ckey.category)))
      ((merge-join fx< K=>1 object=>subject=>eid=>1)
       (lambda (id.K __ X=>eid=>1)
         (let* ((id.name.K (dict-min (dict-get (dict-get curie=>ckey=>cvalue=>1 id.K) ckey.name)))
                (name.K    (id->string id.name.K))
                (K         (id->string id.K)))
           ((merge-join fx< category=>1 category=>curie=>1)
            (lambda (__ ___ X=>1.cprop)
              ((merge-join fx< X=>eid=>1 X=>1.cprop)
               (lambda (id.X eid=>1 __)
                 (let* ((id.name.X (dict-min (dict-get (dict-get curie=>ckey=>cvalue=>1 id.X)
                                                       ckey.name)))
                        (name.X    (id->string id.name.X))
                        (X         (id->string id.X)))
                   ((dict-key-enumerator eid=>1)
                    (lambda (eid)
                      (let ((predicate.X->K
                              (id->string (dict-min (dict-get (dict-get eid=>ekey=>evalue=>1 eid)
                                                              ekey.predicate)))))
                        (yield (list* X name.X predicate.X->K K name.K
                                      (edge-id->properties eid))))))))))))))))
  (define (query.p yield)
    (let* ((ekey.predicate     (string->id str.predicate))
           (ckey.name          (string->id "name"))
           (K=>1               (string*->id=>1 curie*.K))
           (predicate=>1       (string*->id=>1 predicate*.X->K))
           (predicate=>eid=>1  (dict-get ekey=>evalue=>eid=>1   ekey.predicate)))
      ((merge-join fx< K=>1 object=>eid=>subject=>1)
       (lambda (id.K __ eid=>X=>1)
         (let* ((id.name.K (dict-min (dict-get (dict-get curie=>ckey=>cvalue=>1 id.K) ckey.name)))
                (name.K    (id->string id.name.K))
                (K         (id->string id.K)))
           ((merge-join fx< predicate=>1 predicate=>eid=>1)
            (lambda (id.predicate.X->K __ eid=>1)
              (let ((predicate.X->K (id->string id.predicate.X->K)))
                ((merge-join fx< eid=>1 eid=>X=>1)
                 (lambda (eid __ X=>1.edge)
                   ((merge-join fx< X=>1.edge curie=>ckey=>cvalue=>1)
                    (lambda (id.X __ ckey=>cvalue=>1)
                      (let* ((id.name.X (dict-min (dict-get ckey=>cvalue=>1 ckey.name)))
                             (name.X    (id->string id.name.X))
                             (X         (id->string id.X)))
                        (yield (list* X name.X predicate.X->K K name.K
                                      (edge-id->properties eid))))))))))))))))
  (define (query.p&c yield)
    (let* ((ekey.predicate     (string->id str.predicate))
           (ckey.category      (string->id "category"))
           (ckey.name          (string->id "name"))
           (K=>1               (string*->id=>1 curie*.K))
           (predicate=>1       (string*->id=>1 predicate*.X->K))
           (category=>1        (string*->id=>1 category*.X))
           (predicate=>eid=>1  (dict-get ekey=>evalue=>eid=>1   ekey.predicate))
           (category=>curie=>1 (dict-get ckey=>cvalue=>curie=>1 ckey.category)))
      ((merge-join fx< K=>1 object=>eid=>subject=>1)
       (lambda (id.K __ eid=>X=>1)
         (let* ((id.name.K (dict-min (dict-get (dict-get curie=>ckey=>cvalue=>1 id.K) ckey.name)))
                (name.K    (id->string id.name.K))
                (K         (id->string id.K)))
           ((merge-join fx< predicate=>1 predicate=>eid=>1)
            (lambda (id.predicate.X->K __ eid=>1)
              (let ((predicate.X->K (id->string id.predicate.X->K)))
                ((merge-join fx< eid=>1 eid=>X=>1)
                 (lambda (eid __ X=>1.edge)
                   ((merge-join fx< category=>1 category=>curie=>1)
                    (lambda (__ ___ X=>1.cprop)
                      ((dict-join-ordered
                         (lambda (yield)
                           ((merge-join fx< X=>1.cprop X=>1.edge)
                            (lambda (id.X __ ___)
                              (yield id.X '()))))
                         curie=>ckey=>cvalue=>1)
                       (lambda (id.X __ ckey=>cvalue=>1)
                         (let* ((id.name.X (dict-min (dict-get ckey=>cvalue=>1 ckey.name)))
                                (name.X    (id->string id.name.X))
                                (X         (id->string id.X)))
                           (yield (list* X name.X predicate.X->K K name.K
                                         (edge-id->properties eid))))))))))))))))))
  (time (enumerator->rlist (if predicate*.X->K
                               (if category*.X query.p&c query.p)
                               (if category*.X query.c   query.)))))

;; query:Known<-X->Known is analogous to a miniKanren-style query with this shape:
;(run* (K1 name.K1 predicates.K1<-X X name.X predicates.X->K1 K2 name.K2)
;  (fresh (id1 id2 category.X)
;    (edge id1 X K1)
;    (edge id2 X K2)
;    (cprop X   "category" category.X)
;    (cprop X   "name" name.X)
;    (cprop K1  "name" name.K1)
;    (cprop K2  "name" name.K2)
;    (eprop id1 "predicate" K1<-X)
;    (eprop id2 "predicate" X->K2)
;    (membero category.X categories.X)
;    (membero K1         curies.K1)
;    (membero K1<-X      predicates.K1<-X)
;    (membero K2         curies.K2)
;    (membero X->K2      predicates.X->K2)))

(define (query:Known<-X->Known curie*.K1 predicate*.K1<-X category*.X predicate*.X->K2 curie*.K2)
  (define (candidate*->dict candidate*)
    (let* ((candidate* (sort candidate* (lambda (a b) (string<? (car a) (car b)))))
           (group*     (list->vector (s-group candidate* equal? car)))
           (ref.value  (lambda (i) (vector-ref group* i))))
      (dict:ref (lambda (i) (caar (ref.value i))) string<?
                ref.value 0 (vector-length group*))))
  (let* ((X=>XK1=>1 (candidate*->dict (query:X->Known category*.X predicate*.K1<-X curie*.K1)))
         (X=>XK2=>1 (candidate*->dict (query:X->Known category*.X predicate*.X->K2 curie*.K2))))
    (time (enumerator->list
            (lambda (yield)
              ((merge-join string<? X=>XK1=>1 X=>XK2=>1)
               (lambda (X XK1* XK2*)
                 (for-each
                   (lambda (XK1)
                     (match-define (list* _ name.X predicate.X->K1 K1 name.K1 props1) XK1)
                     (for-each
                       (lambda (XK2)
                         (match-define (list* _ _ X->K2 K2 name.K2 props2) XK2)
                         (yield (append (list K1 name.K1 predicate.X->K1 X name.X X->K2 K2 name.K2)
                                        (append props1 props2))))
                       XK2*))
                   XK1*))))))))

(define (query:Known->X->Known curie*.K1 predicate*.K1->X category*.X predicate*.X->K2 curie*.K2)
  (define (KX*->dict candidate*)
    (let* ((candidate* (sort candidate* (lambda (a b) (string<? (cadddr a) (cadddr b)))))
           (group*     (list->vector (s-group candidate* equal? cadddr)))
           (ref.value  (lambda (i) (vector-ref group* i))))
      (dict:ref (lambda (i) (cadddr (car (ref.value i)))) string<?
                ref.value 0 (vector-length group*))))
  (define (XK*->dict candidate*)
    (let* ((candidate* (sort candidate* (lambda (a b) (string<? (car a) (car b)))))
           (group*     (list->vector (s-group candidate* equal? car)))
           (ref.value  (lambda (i) (vector-ref group* i))))
      (dict:ref (lambda (i) (caar (ref.value i))) string<?
                ref.value 0 (vector-length group*))))
  (let* ((X=>K1X* (KX*->dict (query:Known->X curie*.K1 predicate*.K1->X category*.X)))
         (X=>XK2* (XK*->dict (query:X->Known category*.X predicate*.X->K2 curie*.K2))))
    (time (enumerator->list
            (lambda (yield)
              ((merge-join string<? X=>K1X* X=>XK2*)
               (lambda (X K1X* XK2*)
                 (for-each
                   (lambda (K1X)
                     (match-define (list* K1 name.K1 predicate.X->K1 _ name.X props1) K1X)
                     (for-each
                       (lambda (XK2)
                         (match-define (list* _ _ X->K2 K2 name.K2 props2) XK2)
                         (yield (append (list K1 name.K1 predicate.X->K1 X name.X X->K2 K2 name.K2)
                                        (append props1 props2))))
                       XK2*))
                   K1X*))))))))

(define (query:X->Y->Known category*.X predicate*.X->Y category*.Y predicate*.Y->K curie*.K)
  (define (result*->dict key result*)
    (let* ((result*   (sort result* (lambda (a b) (string<? (key a) (key b)))))
           (group*    (list->vector (s-group result* equal? key)))
           (ref.value (lambda (i) (vector-ref group* i))))
      (dict:ref (lambda (i) (key (car (ref.value i)))) string<?
                ref.value 0 (vector-length group*))))
  (let* ((Y=>YK=>1 (result*->dict car    (query:X->Known category*.Y predicate*.Y->K curie*.K)))
         (curie*.Y (enumerator->list (dict-key-enumerator Y=>YK=>1)))
         (Y=>XY=>1 (result*->dict cadddr (query:X->Known category*.X predicate*.X->Y curie*.Y))))
    (time (enumerator->list
            (lambda (yield)
              ((merge-join string<? Y=>XY=>1 Y=>YK=>1)
               (lambda (Y XY* YK*)
                 (for-each
                   (lambda (XY)
                     (match-define (list* X name.X predicate.X->Y _ name.Y props.X->Y) XY)
                     (for-each
                       (lambda (YK)
                         (match-define (list* _ _ Y->K K name.K props.Y->K) YK)
                         (yield (append (list X name.X predicate.X->Y Y name.Y Y->K K name.K)
                                        (append props.X->Y props.Y->K))))
                       YK*))
                   XY*))))))))

(define (query:Known->Known curie*.S predicate*.S->O curie*.O)
  (query:dict.Known->dict.Known
    (string*->id=>1 curie*.S) predicate*.S->O (string*->id=>1 curie*.O)))

(define (query:dict.Known->dict.Known curie=>1.S predicate*.S->O curie=>1.O)
  (define (query yield)
    (let* ((ekey.predicate    (string->id str.predicate))
           (ckey.name         (string->id "name"))
           (predicate=>1      (string*->id=>1 predicate*.S->O))
           (predicate=>eid=>1 (dict-get ekey=>evalue=>eid=>1 ekey.predicate)))
      ((merge-join fx< curie=>1.S subject=>eid=>object=>1)
       (lambda (id.S __ eid=>O=>1)
         (let* ((id.name.S (dict-min (dict-get (dict-get curie=>ckey=>cvalue=>1 id.S) ckey.name)))
                (name.S    (id->string id.name.S))
                (S         (id->string id.S)))
           ((merge-join fx< predicate=>1 predicate=>eid=>1)
            (lambda (id.predicate.S->O __ eid=>1)
              (let ((predicate.S->O (id->string id.predicate.S->O)))
                ((merge-join fx< eid=>1 eid=>O=>1)
                 (lambda (eid __ O=>1)
                   ((merge-join fx< curie=>1.O O=>1)
                    (lambda (id.O __ ___)
                      (let* ((id.name.O (dict-min (dict-get (dict-get curie=>ckey=>cvalue=>1 id.O)
                                                            ckey.name)))
                             (name.O    (id->string id.name.O))
                             (O         (id->string id.O)))
                        (yield (list* S name.S predicate.S->O O name.O
                                      (edge-id->properties eid))))))))))))))))
  (time (enumerator->rlist query)))

(define (query:Concept curie*)
  (define (query yield)
    (let ((curie=>1 (string*->id=>1 curie*)))
      ((merge-join fx< curie=>1 curie=>ckey=>cvalue=>1)
       (lambda (id.curie _ ckey=>cvalue=>1)
         (let ((curie (id->string id.curie)))
           ((dict-enumerator ckey=>cvalue=>1)
            (lambda (id.key cvalue=>1)
              (yield (list curie (id->string id.key) (id->string (dict-min cvalue=>1)))))))))))
  (time (enumerator->list query)))

(define-runtime-path path.here ".")
(define db (database (build-path path.here "name-of-your-database.db")))

(define r.cprop (database-relation db 'cprop))
(define r.edge  (database-relation db 'edge))
(define r.eprop (database-relation db 'eprop))

(define tcell.text=>id (make-thread-cell #f))
(define tcell.id=>text (make-thread-cell #f))

(define (initialize-text!)
  (unless (thread-cell-ref tcell.text=>id)
    (define-values (text=>id id=>text) (relation-text-dicts r.cprop #f))
    (thread-cell-set! tcell.text=>id text=>id)
    (thread-cell-set! tcell.id=>text id=>text)))

(displayln "Loading relation index dictionaries")
(define subject=>object=>eid=>1 (time (relation-index-dict r.edge  '(subject object eid) preload-index?)))
(define object=>subject=>eid=>1 (time (relation-index-dict r.edge  '(object subject eid) preload-index?)))
(define subject=>eid=>object=>1 (time (relation-index-dict r.edge  '(subject eid object) preload-index?)))
(define object=>eid=>subject=>1 (time (relation-index-dict r.edge  '(object eid subject) preload-index?)))
(define ekey=>evalue=>eid=>1    (time (relation-index-dict r.eprop '(key value eid)      preload-index?)))
(define eid=>ekey=>evalue=>1    (time (relation-index-dict r.eprop '(eid key value)      preload-index?)))
(define ckey=>cvalue=>curie=>1  (time (relation-index-dict r.cprop '(key value curie)    preload-index?)))
(define curie=>ckey=>cvalue=>1  (time (relation-index-dict r.cprop '(curie key value)    preload-index?)))
