#lang racket/base
(provide
  (struct-out storage-read-write-methods)
  storage:file-read-only
  storage:file-read-write
  storage:port-read-only
  storage:port-read-write
  storage:bytevector-read-only
  storage:bytevector-read-write
  )
(require
  "../dbk/safe-unsafe.rkt"
  ;racket/unsafe/ops
  racket/fixnum racket/splicing)

;;;;;;;;;;;;;;;
;;; Storage ;;;
;;;;;;;;;;;;;;;

(struct storage-read-write-methods (read write resize))
(define (storage:file-read-only  path)
  (unless (file-exists? path) (error "storage does not exist" path))
  (storage:port-read-only  (open-input-file path)))
(define (storage:file-read-write path)
  (unless (file-exists? path) (error "storage does not exist" path))
  (storage:port-read-write (open-input-file path) (open-output-file path)))
(splicing-local
  ((define (port-read-method in)
     (file-stream-buffer-mode in 'none)
     (lambda (count pos bv.target start.target)
       (file-position in pos)
       ;; NOTE: in must have count bytes available at pos
       (read-bytes! bv.target in start.target (unsafe-fx+ start.target count)))))
  (define (storage:port-read-only in) (port-read-method in))
  (define (storage:port-read-write in out)
    (file-stream-buffer-mode out 'none)
    (storage-read-write-methods
      (port-read-method in)
      (lambda (count pos bv.source start.source)
        (file-position out pos)
        (write-bytes bv.source out start.source (unsafe-fx+ start.source count)))
      (lambda (final-size) (file-truncate out final-size)))))
(define ((storage:bytevector-read-only bv.source start.source) count pos bv.target start.target)
  (let ((start.source (unsafe-fx+ pos start.source)))
    (unsafe-bytes-copy! bv.target start.target bv.source start.source
                        (unsafe-fx+ start.source count))))
(define (storage:bytevector-read-write bv.rw start.rw)
  (storage-read-write-methods
    (storage:bytevector-read-only bv.rw start.rw)
    (lambda (count pos bv.source start.source)
      (unsafe-bytes-copy! bv.rw (unsafe-fx+ pos start.rw) bv.source start.source
                          (unsafe-fx+ start.source count)))
    (lambda (final-size) (void))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Codec for text, nat, and nat-array values ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (unsafe-bytes-text-ref len bv.source start.source)
  (let ((text (make-bytes len)))
    (unsafe-bytes-copy! text 0 bv.source start.source (unsafe-fx+ start.source len))
    text))
(define (unsafe-bytes-text-set! len bv.target start.target text start.text)
  (unsafe-bytes-copy! bv.target start.target text start.text (unsafe-fx+ start.text len)))

(define (unsafe-bytes-nat-array-ref width len bs offset)
  (let ((n-ref (case width
                 ((0) (lambda (offset) 0))
                 ((1) (lambda (offset) (1-unrolled-unsafe-bytes-nat-ref bs offset)))
                 ((2) (lambda (offset) (2-unrolled-unsafe-bytes-nat-ref bs offset)))
                 ((3) (lambda (offset) (3-unrolled-unsafe-bytes-nat-ref bs offset)))
                 ((4) (lambda (offset) (4-unrolled-unsafe-bytes-nat-ref bs offset)))
                 ((5) (lambda (offset) (5-unrolled-unsafe-bytes-nat-ref bs offset)))
                 ((6) (lambda (offset) (6-unrolled-unsafe-bytes-nat-ref bs offset)))))
        (n*    (make-fxvector len 0)))
    (let loop ((i 0) (pos offset))
      (when (unsafe-fx< i len)
        (unsafe-fxvector-set! n* i (n-ref pos))
        (loop (unsafe-fx+ i 1) (unsafe-fx+ pos width))))
    n*))
(define (unsafe-bytes-nat-array-set! width len bs offset n*)
  (let ((n-set! (case width
                  ((0) (lambda (offset n) (void)))
                  ((1) (lambda (offset n) (1-unrolled-unsafe-bytes-nat-set! bs offset n)))
                  ((2) (lambda (offset n) (2-unrolled-unsafe-bytes-nat-set! bs offset n)))
                  ((3) (lambda (offset n) (3-unrolled-unsafe-bytes-nat-set! bs offset n)))
                  ((4) (lambda (offset n) (4-unrolled-unsafe-bytes-nat-set! bs offset n)))
                  ((5) (lambda (offset n) (5-unrolled-unsafe-bytes-nat-set! bs offset n)))
                  ((6) (lambda (offset n) (6-unrolled-unsafe-bytes-nat-set! bs offset n))))))
    (let loop ((i 0) (pos offset))
      (when (unsafe-fx< i len)
        (n-set! pos (unsafe-fxvector-ref n* i))
        (loop (unsafe-fx+ i 1) (unsafe-fx+ pos width))))))

(define (unsafe-bytes-nat-set! width bs offset n)
  (case width
    ((1)  (1-unrolled-unsafe-bytes-nat-set! bs offset n))
    ((2)  (2-unrolled-unsafe-bytes-nat-set! bs offset n))
    ((3)  (3-unrolled-unsafe-bytes-nat-set! bs offset n))
    ((4)  (4-unrolled-unsafe-bytes-nat-set! bs offset n))
    ((5)  (5-unrolled-unsafe-bytes-nat-set! bs offset n))
    ((6)  (6-unrolled-unsafe-bytes-nat-set! bs offset n))
    (else (rolled-unsafe-bytes-nat-set! width bs offset n))))
(define (rolled-unsafe-bytes-nat-set! width bs offset n)
  (let loop ((i     offset)
             (shift (unsafe-fxlshift (unsafe-fx- width 1) 3)))
    (when (unsafe-fx<= 0 shift)
      (unsafe-bytes-set! bs i (unsafe-fxand 255 (unsafe-fxrshift n shift)))
      (loop (unsafe-fx+ i     1)
            (unsafe-fx- shift 8)))))
(define (1-unrolled-unsafe-bytes-nat-set! bs i n) (unsafe-bytes-set! bs i n))
(define (2-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 n)))
(define (3-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 16)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 2) (unsafe-fxand 255 n)))
(define (4-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 24)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 (unsafe-fxrshift n 16)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 2) (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 3) (unsafe-fxand 255 n)))
(define (5-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 32)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 (unsafe-fxrshift n 24)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 2) (unsafe-fxand 255 (unsafe-fxrshift n 16)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 3) (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 4) (unsafe-fxand 255 n)))
(define (6-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 40)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 (unsafe-fxrshift n 32)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 2) (unsafe-fxand 255 (unsafe-fxrshift n 24)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 3) (unsafe-fxand 255 (unsafe-fxrshift n 16)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 4) (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 5) (unsafe-fxand 255 n)))
(define (unsafe-bytes-nat-ref width bs offset)
  (case width
    ((1)  (1-unrolled-unsafe-bytes-nat-ref bs offset))
    ((2)  (2-unrolled-unsafe-bytes-nat-ref bs offset))
    ((3)  (3-unrolled-unsafe-bytes-nat-ref bs offset))
    ((4)  (4-unrolled-unsafe-bytes-nat-ref bs offset))
    ((5)  (5-unrolled-unsafe-bytes-nat-ref bs offset))
    ((6)  (6-unrolled-unsafe-bytes-nat-ref bs offset))
    (else (rolled-unsafe-bytes-nat-ref width bs offset))))
(define (rolled-unsafe-bytes-nat-ref width bs offset)
  (let ((end (unsafe-fx+ offset width)))
    (let loop ((i offset) (n 0))
      (cond ((unsafe-fx< i end) (loop (unsafe-fx+ i 1)
                                      (unsafe-fx+ (unsafe-fxlshift n 8)
                                                  (unsafe-bytes-ref bs i))))
            (else               n)))))
(define (1-unrolled-unsafe-bytes-nat-ref bs i) (unsafe-bytes-ref bs i))
(define (2-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fx+ (unsafe-fxlshift (unsafe-bytes-ref bs             i)     8)
              (unsafe-bytes-ref                  bs (unsafe-fx+ i 1))))
(define (3-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fx+ (unsafe-fxlshift (unsafe-bytes-ref bs             i)    16)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 1))  8)
              (unsafe-bytes-ref                  bs (unsafe-fx+ i 2))))
(define (4-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fx+ (unsafe-fxlshift (unsafe-bytes-ref bs             i)    24)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 1)) 16)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 2))  8)
              (unsafe-bytes-ref                  bs (unsafe-fx+ i 3))))
(define (5-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fx+ (unsafe-fxlshift (unsafe-bytes-ref bs             i)    32)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 1)) 24)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 2)) 16)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 3))  8)
              (unsafe-bytes-ref                  bs (unsafe-fx+ i 4))))
(define (6-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fx+ (unsafe-fxlshift (unsafe-bytes-ref bs             i)    40)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 1)) 32)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 2)) 24)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 3)) 16)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 4))  8)
              (unsafe-bytes-ref                  bs (unsafe-fx+ i 5))))

(define (min-bits n)
  (let loop ((n n))
    (if (< 0 n) (+ 1 (loop (fxrshift n 1))) 0)))
(define (min-bytes n)
  (let ((bits (min-bits n)))
    (+ (quotient bits 8) (if (= 0 (remainder bits 8)) 0 1))))
(define (nat-min-byte-width nat.max) (max (min-bytes nat.max) 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Structure specification ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (structure-size-min S)
  (let loop/size ((S* (list S)) (size 0))
    (define (loop S*) (loop/size S* size))
    (syntax-case S* (struct size-= size-min byte bytes text array case)
      ((((bytes count) name ...) rest ...)
       (let ((count (syntax->datum #'count)))
         (loop/size #'(rest ...) (+ (if (integer? count)
                                        (* count (length (syntax->list #'(name ...))))
                                        0)
                                    size))))
      ((((text len) name ...) rest ...)
       (loop/size #'(rest ...) (+ (let ((len (syntax->datum #'len)))
                                    (if (integer? len)
                                        (* len (length (syntax->list #'(name ...))))
                                        0))
                                  size)))
      ((((array count len) name ...) rest ...)
       (loop/size #'(rest ...) (+ (let ((count (syntax->datum #'count))
                                        (len   (syntax->datum #'len)))
                                    (if (and (integer? count) (integer? len))
                                        (* count len (length (syntax->list #'(name ...))))
                                        0))
                                  size)))
      (((case _ (_ clause) ...) rest ...)
       (loop/size #'(rest ...) (apply min (map loop (map list (syntax->list #'(clause ...)))))))
      (((struct body ...) rest ...) (loop #'(body ... rest ...)))
      (((byte name ...)   rest ...) (loop #'(((bytes 1) name ...) rest ...)))
      (((size-=   count)  rest ...) (loop #'((size-max count) (size-min count) rest ...)))
      (((size-min count)  rest ...) (let ((count (syntax->datum #'count)))
                                      (if (integer? count)
                                          (+ count size)
                                          (loop #'(rest ...)))))
      ((_                 rest ...) (loop #'(rest ...)))
      (()                           size))))

(define (structure-size-max S)
  (let loop/size ((S* (list S)) (size 0))
    (define (loop S*) (loop/size S* size))
    (syntax-case S* (struct size-= size-max byte bytes text array case)
      ((((bytes count) name ...) rest ...)
       (let ((count (syntax->datum #'count)))
         (and (integer? count)
              (loop/size #'(rest ...) (+ (* count (length (syntax->list #'(name ...)))) size)))))
      ((((text len) name ...) rest ...)
       (let ((len (syntax->datum #'len)))
         (and (integer? len)
              (loop/size #'(rest ...) (+ (* len (length (syntax->list #'(name ...)))) size)))))
      ((((array count len) name ...) rest ...)
       (let ((count (syntax->datum #'count))
             (len   (syntax->datum #'len)))
         (and (integer? count) (integer? len)
              (loop/size #'(rest ...) (+ (* count len (length (syntax->list #'(name ...))))
                                         size)))))
      (((case _ (_ clause) ...) rest ...)
       (let ((size* (map loop (map list (syntax->list #'(clause ...))))))
         (and (not (ormap not size*))
              (loop/size #'(rest ...) (apply max size*)))))
      (((struct body ...) rest ...) (loop #'(body ... rest ...)))
      (((byte name ...)   rest ...) (loop #'(((bytes 1) name ...) rest ...)))
      (((size-=   count)  rest ...) (loop #'((size-max count) (size-min count) rest ...)))
      (((size-max count)  rest ...) (let ((count (syntax->datum #'count)))
                                      (if (integer? count)
                                          (+ count size)
                                          (loop #'(rest ...)))))
      ((_                 rest ...) (loop #'(rest ...)))
      (()                           size))))

(define (structure-env-lookup env x)
  (unless (identifier? x) (error "not a discriminated identifier" x))
  (let loop ((env env))
    (if (null? env)
        (error "not discriminated" x)
        (let ((next (car env)))
          (if (free-identifier=? (car next) x)
              (cdr next)
              (loop (cdr env)))))))

(define (structure-compile-read/size-check S E.buffer E.limit.left E.limit.right E.k.fail E*.succeed)
  #`(let ((k.fail #,E.k.fail))
      (let retry ((buffer #,E.buffer)
                  (end    #,E.limit.left)
                  (cur    #,E.limit.right))
        (if (unsafe-fx< (unsafe-fx- cur end) #,(structure-size-min S))
            (k.fail retry)
            #,(let loop/env ((S* (list S)) (env '()))
                (define (loop S*) (loop/env S* env))
                (syntax-case S* (struct size-= size-min size-max byte bytes text array
                                        let here discriminate case)
                  ((((bytes E.count) name) rest ...)
                   #`(let* ((count E.count)
                            (cur   (unsafe-fx- cur count)))
                       (let ((name (unsafe-bytes-nat-ref count buffer cur))) #,(loop #'(rest ...)))))
                  ((((array E.count E.len) name) rest ...)
                   #`(let* ((count E.count)
                            (len   E.len)
                            (cur   (unsafe-fx- cur (unsafe-fx* count len))))
                       (let ((name (unsafe-bytes-nat-array-ref count len buffer cur)))
                         #,(loop #'(rest ...)))))
                  ((((text E.len) name) rest ...)
                   #`(let* ((len E.len)
                            (cur (unsafe-fx- cur len)))
                       (let ((name (unsafe-bytes-text-ref len buffer cur))) #,(loop #'(rest ...)))))
                  ((((bytes c)   name ...) rest ...) (loop #'(((bytes c)   name) ... rest ...)))
                  ((((array c l) name ...) rest ...) (loop #'(((array c l) name) ... rest ...)))
                  ((((text l)    name ...) rest ...) (loop #'(((text l)    name) ... rest ...)))
                  (((let name body) rest ...) #`(let ((name body)) #,(loop #'(rest ...))))
                  (((here name ...) rest ...) #`(let ((name cur) ...) #,(loop #'(rest ...))))
                  (((discriminate name choice) rest ...)
                   (loop/env #'(rest ...) (cons (cons #'name (syntax->datum #'choice)) env)))
                  (((discriminate name choice more ...) rest ...)
                   #`(if (eq? name choice)
                         #,(loop/env #'(rest ...)
                                     (cons (cons #'name (syntax->datum #'choice)) env))
                         #,(loop #'((discriminate name more ...) rest ...))))
                  (((case x clause ...) rest ...)
                   (let ((choice (structure-env-lookup env #'x)))
                     (let loop.clause* ((clause* #'(clause ...)))
                       (syntax-case clause* (else)
                         (() (error "no matching clause for choice"
                                    #'x choice #'(case x clause ...)))
                         (((() _) more ...) (loop.clause* #'(more ...)))
                         ((((val val* ...) body) more ...)
                          (if (eq? (syntax->datum #'val) choice)
                              (loop #'(body rest ...))
                              (loop.clause* #'(((val* ...) body) more ...))))
                         (((else body))       (loop #'(body rest ...)))
                         (((else _) more ...) (error "misplaced else" #'(case x clause ...)))))))
                  (((struct body ...) rest ...) (loop #'(body ... rest ...)))
                  (((byte name ...)   rest ...) (loop #'(((bytes 1) name ...) rest ...)))
                  (((size-= sz)       rest ...) (loop #'((size-max sz) (size-min sz) rest ...)))
                  (((size-max sz)     rest ...) (loop #'(rest ...)))
                  (((size-min sz) rest ...)
                   #`(let ((retry (lambda (buffer end cur) #,(loop #'(rest ...)))))
                       (if (unsafe-fx< (unsafe-fx- cur end) sz)
                           (k.fail retry)
                           (retry buffer end cur))))
                  (() #`(begin
                          . #,(map (lambda (E.succeed)
                                     (syntax-case E.succeed (case)
                                       ((case x clause ...)
                                        (let ((choice (structure-env-lookup env #'x)))
                                          (let loop.clause* ((clause* #'(clause ...)))
                                            (syntax-case clause* (else)
                                              (() (error "no matching clause for choice"
                                                         #'x choice #'(case x clause ...)))
                                              (((() _ ...) more ...) (loop.clause* #'(more ...)))
                                              ((((val val* ...) body ...) more ...)
                                               (if (eq? (syntax->datum #'val) choice)
                                                   #'(begin body ...)
                                                   (loop.clause* #'(((val* ...) body ...)
                                                                    more ...))))
                                              (((else body ...)) #'(begin body ...))
                                              (((else _) more ...)
                                               (error "misplaced else" #'(case x clause ...)))))))
                                       (_ E.succeed)))
                                   E*.succeed)))))))))

(define (structure-compile-read S E.buffer E.limit.right E*.succeed)
  #`(let ((buffer #,E.buffer)
          (cur    #,E.limit.right))
      #,(let loop/env ((S* (list S)) (env '()))
          (define (loop S*) (loop/env S* env))
          (syntax-case S* (struct size-= size-min size-max byte bytes text array
                                  let here discriminate case)
            ((((bytes E.count) name) rest ...)
             #`(let* ((count E.count)
                      (cur   (unsafe-fx- cur count)))
                 (let ((name (unsafe-bytes-nat-ref count buffer cur))) #,(loop #'(rest ...)))))
            ((((array E.count E.len) name) rest ...)
             #`(let* ((count E.count)
                      (len   E.len)
                      (cur   (unsafe-fx- cur (unsafe-fx* count len))))
                 (let ((name (unsafe-bytes-nat-array-ref count len buffer cur)))
                   #,(loop #'(rest ...)))))
            ((((text E.len) name) rest ...)
             #`(let* ((len E.len)
                      (cur (unsafe-fx- cur len)))
                 (let ((name (unsafe-bytes-text-ref len buffer cur))) #,(loop #'(rest ...)))))
            ((((bytes c)   name ...) rest ...) (loop #'(((bytes c)   name) ... rest ...)))
            ((((array c l) name ...) rest ...) (loop #'(((array c l) name) ... rest ...)))
            ((((text l)    name ...) rest ...) (loop #'(((text l)    name) ... rest ...)))
            (((let name body) rest ...) #`(let ((name body)) #,(loop #'(rest ...))))
            (((here name ...) rest ...) #`(let ((name cur) ...) #,(loop #'(rest ...))))
            (((discriminate name choice) rest ...)
             (loop/env #'(rest ...) (cons (cons #'name (syntax->datum #'choice)) env)))
            (((discriminate name choice more ...) rest ...)
             #`(if (eq? name choice)
                   #,(loop/env #'(rest ...)
                               (cons (cons #'name (syntax->datum #'choice)) env))
                   #,(loop #'((discriminate name more ...) rest ...))))
            (((case x clause ...) rest ...)
             (let ((choice (structure-env-lookup env #'x)))
               (let loop.clause* ((clause* #'(clause ...)))
                 (syntax-case clause* (else)
                   (() (error "no matching clause for choice"
                              #'x choice #'(case x clause ...)))
                   (((() _) more ...) (loop.clause* #'(more ...)))
                   ((((val val* ...) body) more ...)
                    (if (eq? (syntax->datum #'val) choice)
                        (loop #'(body rest ...))
                        (loop.clause* #'(((val* ...) body) more ...))))
                   (((else body))       (loop #'(body rest ...)))
                   (((else _) more ...) (error "misplaced else" #'(case x clause ...)))))))
            (((struct body ...) rest ...) (loop #'(body ... rest ...)))
            (((byte name ...)   rest ...) (loop #'(((bytes 1) name ...) rest ...)))
            (((size-= sz)       rest ...) (loop #'((size-max sz) (size-min sz) rest ...)))
            (((size-max sz)     rest ...) (loop #'(rest ...)))
            (((size-min sz)     rest ...) (loop #'(rest ...)))
            (() #`(begin . #,(map (lambda (E.succeed)
                                    (syntax-case E.succeed (case)
                                      ((case x clause ...)
                                       (let ((choice (structure-env-lookup env #'x)))
                                         (let loop.clause* ((clause* #'(clause ...)))
                                           (syntax-case clause* (else)
                                             (() (error "no matching clause for choice"
                                                        #'x choice #'(case x clause ...)))
                                             (((() _ ...) more ...) (loop.clause* #'(more ...)))
                                             ((((val val* ...) body ...) more ...)
                                              (if (eq? (syntax->datum #'val) choice)
                                                  #'(begin body ...)
                                                  (loop.clause* #'(((val* ...) body ...)
                                                                   more ...))))
                                             (((else body ...)) #'(begin body ...))
                                             (((else _) more ...)
                                              (error "misplaced else" #'(case x clause ...)))))))
                                      (_ E.succeed)))
                                  E*.succeed)))))))

;; NOTE: assumes buffer is large enough
(define (structure-compile-write S env E.buffer E.limit.right E.k.succeed)
  #`(let ((buffer #,E.buffer)
          (cur    #,E.limit.right))
      #,(let loop ((S* (list S)))
          (syntax-case S* (struct size-= size-min size-max byte bytes text array
                                  let here discriminate case)
            ((((bytes E.count) name) rest ...)
             #`(let* ((count E.count)
                      (cur   (unsafe-fx- cur count)))
                 (unsafe-bytes-nat-set! count buffer cur name)
                 #,(loop #'(rest ...))))
            ((((array E.count E.len) name) rest ...)
             #`(let* ((count E.count)
                      (len   E.len)
                      (cur   (unsafe-fx- cur (unsafe-fx* count len))))
                 (unsafe-bytes-nat-array-set! count len buffer cur name)
                 #,(loop #'(rest ...))))
            ((((text E.len) name) rest ...)
             #`(let* ((len E.len)
                      (cur (unsafe-fx- cur len)))
                 (unsafe-bytes-text-set! len buffer cur name 0)
                 #,(loop #'(rest ...))))
            ((((bytes c)   name ...) rest ...) (loop #'(((bytes c)   name) ... rest ...)))
            ((((array c l) name ...) rest ...) (loop #'(((array c l) name) ... rest ...)))
            ((((text l)    name ...) rest ...) (loop #'(((text l)    name) ... rest ...)))
            (((let name body) rest ...) #`(let ((name body)) #,(loop #'(rest ...))))
            (((here name ...) rest ...) #`(let ((name cur) ...) #,(loop #'(rest ...))))
            (((discriminate name choice more ...) rest ...) (loop #'(rest ...)))
            (((case x clause ...) rest ...)
             (let ((choice (structure-env-lookup env #'x)))
               (let loop.clause* ((clause* #'(clause ...)))
                 (syntax-case clause* (else)
                   (() (error "no matching clause for choice"
                              #'x choice #'(case x clause ...)))
                   (((() _) more ...) (loop.clause* #'(more ...)))
                   ((((val val* ...) body) more ...)
                    (if (eq? (syntax->datum #'val) choice)
                        (loop #'(body rest ...))
                        (loop.clause* #'(((val* ...) body) more ...))))
                   (((else body))       (loop #'(body rest ...)))
                   (((else _) more ...) (error "misplaced else" #'(case x clause ...)))))))
            (((struct body ...) rest ...) (loop #'(body ... rest ...)))
            (((byte name ...)   rest ...) (loop #'(((bytes 1) name ...) rest ...)))
            (((size-=   sz)     rest ...) (loop #'((size-max sz) (size-min sz) rest ...)))
            (((size-max sz)     rest ...) (loop #'(rest ...)))
            (((size-min sz)     rest ...) (loop #'(rest ...)))
            (()                           #`(#,E.k.succeed cur))))))

;;;;;;;;;;;;;;;;
;;; Examples ;;;
;;;;;;;;;;;;;;;;

(define stx.btt-node
  #'(struct
      (size-max 4096)
      ;(size-= 10)
      ;(size-min 10)
      (byte b0 b1 b2 count.key*)
      (let count.key* (unsafe-fx+ count.key* 1))
      (let size.body (unsafe-fx+ (unsafe-fxlshift (unsafe-fxand #b1111 b1) 8) b2))
      (size-= size.body)
      (here address.body.start)
      (let address.body.end (unsafe-fx+ address.body.start size.body))
      ;; TODO: unused bits
      ;(unsafe-fxand #b1 (unsafe-fxrshift b0 6))
      ;(unsafe-fxand #b1 (unsafe-fxrshift b1 4))
      (let bytecount.length.shared-prefix (unsafe-fxand #b111 (unsafe-fxrshift b0 3)))
      (let bytecount.length-key           (unsafe-fxand #b111 b0))
      (let bytecount.address.payload      (unsafe-fxand #b111 (unsafe-fxrshift b1 5)))
      ((array bytecount.length.shared-prefix count.key*) length*.shared-prefix)
      ((array bytecount.length.key           count.key*) length*.key)
      ;; type:
      ;; - 0: leaf
      ;; - 1: internal
      (let type.node (unsafe-fxrshift b0 7))
      ;; NOTE: the +1 is for the largest payload address that fits on the same page as this node.
      ((array bytecount.address.payload (unsafe-fx+ type.node count.key* 1)) address*.payload)
      (discriminate type.node 0 1)
      (case type.node
        ((0) (struct))
        ((1) ((bytes 6) max-reachable-cardinality-offset)))
      (here address.key*)))

(require racket/pretty)
(define-syntax-rule (pretty-result E) (pretty-write `(E ==> ,E)))

(pretty-result (structure-size-min stx.btt-node))
(pretty-result (structure-size-max stx.btt-node))
(pretty-result
  (syntax->datum
    (structure-compile-read stx.btt-node #'E.buffer #'E.limit.right (list #'E.succeed))))
(pretty-result
  (syntax->datum
    (structure-compile-write
      stx.btt-node
      `((,#'type.node . 0))
      #'E.buffer
      #'E.limit.right
      #'E.k.succeed)))
(pretty-result
  (syntax->datum
    (structure-compile-write
      stx.btt-node
      `((,#'type.node . 1))
      #'E.buffer
      #'E.limit.right
      #'E.k.succeed)))
