#lang racket/base
(require racket/fixnum racket/list racket/pretty)
(require
  ;"../../dbk/safe-unsafe.rkt"
  racket/unsafe/ops
  )

;;; Frame-of-reference compression for integers

(define (min-bits n)
  (let loop ((n n))
    (if (< 0 n) (+ 1 (loop (fxrshift n 1))) 0)))
(define (min-bytes n)
  (let ((bits (min-bits n)))
    (+ (quotient bits 8) (if (= 0 (remainder bits 8)) 0 1))))
(define (nat-min-byte-width nat.max) (max (min-bytes nat.max) 1))

(define (unsafe-bytes-nat-array-ref width len bs offset)
  (let ((go (lambda (n-ref)
              (let ((n* (make-fxvector len 0)))
                (let loop ((i 0) (pos offset))
                  (when (unsafe-fx< i len)
                    (unsafe-fxvector-set! n* i (n-ref bs pos))
                    (loop (unsafe-fx+ i 1) (unsafe-fx+ pos width))))
                n*))))
    (case width
      ((0) (make-fxvector len 0))
      ((1) (go 1-unrolled-unsafe-bytes-nat-ref))
      ((2) (go 2-unrolled-unsafe-bytes-nat-ref))
      ((3) (go 3-unrolled-unsafe-bytes-nat-ref))
      ((4) (go 4-unrolled-unsafe-bytes-nat-ref))
      ((5) (go 5-unrolled-unsafe-bytes-nat-ref))
      ((6) (go 6-unrolled-unsafe-bytes-nat-ref)))))
(define (unsafe-bytes-nat-array-set! width len bs offset n*)
  (let ((go (lambda (n-set!)
              (let loop ((i 0) (pos offset))
                (when (unsafe-fx< i len)
                  (n-set! bs pos (unsafe-fxvector-ref n* i))
                  (loop (unsafe-fx+ i 1) (unsafe-fx+ pos width)))))))
    (case width
      ((0) (void))
      ((1) (go 1-unrolled-unsafe-bytes-nat-set!))
      ((2) (go 2-unrolled-unsafe-bytes-nat-set!))
      ((3) (go 3-unrolled-unsafe-bytes-nat-set!))
      ((4) (go 4-unrolled-unsafe-bytes-nat-set!))
      ((5) (go 5-unrolled-unsafe-bytes-nat-set!))
      ((6) (go 6-unrolled-unsafe-bytes-nat-set!)))))

(define (unsafe-bytes-nat-set! width bs offset n)
  (case width
    ((1)  (1-unrolled-unsafe-bytes-nat-set! bs offset n))
    ((2)  (2-unrolled-unsafe-bytes-nat-set! bs offset n))
    ((3)  (3-unrolled-unsafe-bytes-nat-set! bs offset n))
    ((4)  (4-unrolled-unsafe-bytes-nat-set! bs offset n))
    ((5)  (5-unrolled-unsafe-bytes-nat-set! bs offset n))
    ((6)  (6-unrolled-unsafe-bytes-nat-set! bs offset n))
    (else (rolled-unsafe-bytes-nat-set! width bs offset n))))
(define (rolled-unsafe-bytes-nat-set! width bs offset n)
  (let loop ((i     offset)
             (shift (unsafe-fxlshift (unsafe-fx- width 1) 3)))
    (when (unsafe-fx<= 0 shift)
      (unsafe-bytes-set! bs i (unsafe-fxand 255 (unsafe-fxrshift n shift)))
      (loop (unsafe-fx+ i     1)
            (unsafe-fx- shift 8)))))
(define (1-unrolled-unsafe-bytes-nat-set! bs i n) (unsafe-bytes-set! bs i n))
(define (2-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 n)))
(define (3-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 16)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 2) (unsafe-fxand 255 n)))
(define (4-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 24)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 (unsafe-fxrshift n 16)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 2) (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 3) (unsafe-fxand 255 n)))
(define (5-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 32)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 (unsafe-fxrshift n 24)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 2) (unsafe-fxand 255 (unsafe-fxrshift n 16)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 3) (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 4) (unsafe-fxand 255 n)))
(define (6-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 40)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 (unsafe-fxrshift n 32)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 2) (unsafe-fxand 255 (unsafe-fxrshift n 24)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 3) (unsafe-fxand 255 (unsafe-fxrshift n 16)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 4) (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 5) (unsafe-fxand 255 n)))
(define (unsafe-bytes-nat-ref width bs offset)
  (case width
    ((1)  (1-unrolled-unsafe-bytes-nat-ref bs offset))
    ((2)  (2-unrolled-unsafe-bytes-nat-ref bs offset))
    ((3)  (3-unrolled-unsafe-bytes-nat-ref bs offset))
    ((4)  (4-unrolled-unsafe-bytes-nat-ref bs offset))
    ((5)  (5-unrolled-unsafe-bytes-nat-ref bs offset))
    ((6)  (6-unrolled-unsafe-bytes-nat-ref bs offset))
    (else (rolled-unsafe-bytes-nat-ref width bs offset))))
(define (rolled-unsafe-bytes-nat-ref width bs offset)
  (let ((end (unsafe-fx+ offset width)))
    (let loop ((i offset) (n 0))
      (cond ((unsafe-fx< i end) (loop (unsafe-fx+ i 1)
                                      (unsafe-fx+ (unsafe-fxlshift n 8)
                                                  (unsafe-bytes-ref bs i))))
            (else               n)))))
(define (1-unrolled-unsafe-bytes-nat-ref bs i) (unsafe-bytes-ref bs i))
(define (2-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fx+ (unsafe-fxlshift (unsafe-bytes-ref bs             i)     8)
              (unsafe-bytes-ref                  bs (unsafe-fx+ i 1))))
(define (3-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fx+ (unsafe-fxlshift (unsafe-bytes-ref bs             i)    16)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 1))  8)
              (unsafe-bytes-ref                  bs (unsafe-fx+ i 2))))
(define (4-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fx+ (unsafe-fxlshift (unsafe-bytes-ref bs             i)    24)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 1)) 16)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 2))  8)
              (unsafe-bytes-ref                  bs (unsafe-fx+ i 3))))
(define (5-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fx+ (unsafe-fxlshift (unsafe-bytes-ref bs             i)    32)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 1)) 24)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 2)) 16)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 3))  8)
              (unsafe-bytes-ref                  bs (unsafe-fx+ i 4))))
(define (6-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fx+ (unsafe-fxlshift (unsafe-bytes-ref bs             i)    40)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 1)) 32)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 2)) 24)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 3)) 16)
              (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 4))  8)
              (unsafe-bytes-ref                  bs (unsafe-fx+ i 5))))

;; Fit into 4 bytes
;(define v.min -16250000)
;(define v.max  16250000)

;(define v.min -10000000)
;(define v.max  10000000)

;; Fit into 3 bytes
(define v.min -8000000)
(define v.max  8000000)

(define count (- v.max v.min))

(define byte-width (nat-min-byte-width count))
(define v.ref      (- (arithmetic-shift 1 (- (* 8 byte-width) 1))))
(pretty-write `(count: ,count byte-width: ,byte-width v.ref: ,v.ref))

;(define bw2 (* byte-width 2))
;(define bw3 (* byte-width 3))
;(define bw4 (* byte-width 4))

;; NOTE: using fxvector instead does not impact performance.
(define input           (make-vector count))
(define input.roundtrip (make-vector count))
(define size            (* count byte-width))
(define output          (make-bytes size))

(define (generate-input)
  (time (let loop ((i 0))
          (when (unsafe-fx< i count)
            (unsafe-vector*-set! input i (unsafe-fx+ v.min i))
            (loop (unsafe-fx+ i 1))))))

(define (encode-input)
  (define (encode n) (unsafe-fx- n v.ref))
  (let ((n-set! (case byte-width
                  ((1) 1-unrolled-unsafe-bytes-nat-set!)
                  ((2) 2-unrolled-unsafe-bytes-nat-set!)
                  ((3) 3-unrolled-unsafe-bytes-nat-set!)
                  ((4) 4-unrolled-unsafe-bytes-nat-set!)
                  ((5) 5-unrolled-unsafe-bytes-nat-set!)
                  ((6) 6-unrolled-unsafe-bytes-nat-set!)
                  (else (error "invalid byte width" byte-width)))))
    ;; TODO: experiment with loop unrolling? (though it had no impact for decoding)
    (time (let loop ((i 0) (start 0))
            (when (unsafe-fx< i count)
              (n-set! output start (encode (unsafe-vector*-ref input i)))
              (loop (unsafe-fx+ i 1) (unsafe-fx+ start byte-width)))))))

(define (decode-output)
  (define (decode n) (unsafe-fx+ n v.ref))
  (let ((n-ref (case byte-width
                 ((1) 1-unrolled-unsafe-bytes-nat-ref)
                 ((2) 2-unrolled-unsafe-bytes-nat-ref)
                 ((3) 3-unrolled-unsafe-bytes-nat-ref)
                 ((4) 4-unrolled-unsafe-bytes-nat-ref)
                 ((5) 5-unrolled-unsafe-bytes-nat-ref)
                 ((6) 6-unrolled-unsafe-bytes-nat-ref)
                 (else (error "invalid byte width" byte-width)))))
    ;; NOTE: loop unrolling does not impact performance.
    (time (let loop ((i 0) (start 0))
            (when (unsafe-fx< i count)
              (unsafe-vector*-set! input.roundtrip i (decode (n-ref output start)))
              (loop (unsafe-fx+ i 1) (unsafe-fx+ start byte-width)))))))

;(count: 32500000 byte-width: 4 v.ref: -2147483648)
;cpu time: 596 real time: 597 gc time: 520
;cpu time: 199 real time: 203 gc time: 0
;cpu time: 173 real time: 178 gc time: 0
;(count: 20000000 byte-width: 4 v.ref: -2147483648)
;cpu time: 382 real time: 383 gc time: 337
;cpu time: 131 real time: 134 gc time: 0
;cpu time: 107 real time: 111 gc time: 0
;(count: 16000000 byte-width: 3 v.ref: -8388608)
;cpu time: 312 real time: 314 gc time: 274
;cpu time: 85 real time: 87 gc time: 0
;cpu time: 74 real time: 75 gc time: 0
(generate-input)
(encode-input)
(decode-output)

(pretty-write (subbytes output 0 100))
(pretty-write (subbytes output 10000 10100))

(pretty-write (map (lambda (i) (vector-ref input.roundtrip i)) (range 10)))
(pretty-write (map (lambda (i) (vector-ref input.roundtrip (- (vector-length input.roundtrip) (+ 1 i)))) (reverse (range 10))))
