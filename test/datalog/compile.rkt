#lang racket/base
(provide
  current-primitive-relations
  primitive-relations.base
  parse-rule)
(require racket/match racket/set)

(define (relation-name            R) (cadr R))
(define (relation-original?       R) (eq? (car R) 'orig))
(define (relation-original     name) (list 'orig name))

(define (relation-generated?      R) (eq? (car R) 'new))
(define (relation-generated    name) (list 'new  name))

(define (relation-primitive?      R) (eq? (car R) 'prim))
(define (relation-primitive    name) (list 'prim name))

(define (relation-negation?       R) (eq? (car R) 'not))
(define (relation-negation R.target) (list 'not  R.target))
(define (relation-negation-target R) (cadr R))

(define (atom        R args) (cons R args))
(define (atom-relation atom) (car atom))
(define (atom-args     atom) (cdr atom))

(define (var?           t) (eq? (car t) 'var))
(define (var         name) (list 'var   name))
(define (var-name       x) (cadr x))

(define (constant?      t) (eq? (car t) 'quote))
(define (constant   value) (list 'quote value))
(define (constant-value c) (eq? (car c) 'quote))

(define (rule head body) (cons head body))
(define (rule-head    r) (car r))
(define (rule-body    r) (cdr r))

(define prim.==            (relation-primitive '==))
(define prim.=/=           (relation-negation  prim.==))
(define prim.<             (relation-primitive '<))
(define prim.<=            (relation-primitive '<=))
(define prim.type==        (relation-primitive 'type==))
(define prim.cons==        (relation-primitive 'cons==))
(define prim.+==           (relation-primitive '+==))
(define prim.*==           (relation-primitive '*==))
(define prim.symbol-string (relation-primitive 'symbol-string))
(define prim.string-bytes  (relation-primitive 'string-bytes))
(define prim.bytes-list    (relation-primitive 'bytes-list))
(define prim.vector-list   (relation-primitive 'vector-list))

(define (==            t0 t1)          (atom prim.==            (list t0 t1)))
(define (=/=           t0 t1)          (atom prim.=/=           (list t0 t1)))
(define (type==        t     t.result) (atom prim.type==        (list t     t.result)))
(define (cons==        t0 t1 t.result) (atom prim.cons==        (list t0 t1 t.result)))
(define (+==           t0 t1 t.result) (atom prim.+==           (list t0 t1 t.result)))
(define (*==           t0 t1 t.result) (atom prim.*==           (list t0 t1 t.result)))
(define (symbol-string t0 t1)          (atom prim.symbol-string (list t0 t1)))
(define (string-bytes  t0 t1)          (atom prim.string-bytes  (list t0 t1)))
(define (bytes-list    t0 t1)          (atom prim.bytes-list    (list t0 t1)))
(define (vector-list   t0 t1)          (atom prim.vector-list   (list t0 t1)))

(define primitive-relations.base
  (hash '==           ==
        '=/=          =/=
        '<            (lambda (t0 t1) (atom prim.<  (list t0 t1)))
        '<=           (lambda (t0 t1) (atom prim.<= (list t0 t1)))
        '>            (lambda (t0 t1) (atom prim.<  (list t1 t0)))
        '>=           (lambda (t0 t1) (atom prim.<= (list t1 t0)))))

(define current-primitive-relations (make-parameter (hash)))

(define (parse-fact         e) (atom (relation-original (car e)) (cdr e)))
(define (parse-atom         e) (atom (relation-original (car e)) (map parse-term (cdr e))))
(define (parse-negated-atom e) (let ((a (parse-atom e)))
                                 (atom (relation-negation (atom-relation a)) (atom-args a))))

(define (parse-term e)
  (define (build-cons a d) (let ((result (fresh-var)))
                             (implicit-atom! (cons== a d result))
                             result))
  (define (build-list ts)  (foldr build-cons (constant '()) ts))
  (define (build-l2r R e)  (let ((result (fresh-var)))
                             (implicit-atom! (R (parse-term e) result))
                             result))
  (define (build-r2l R e)  (let ((result (fresh-var)))
                             (implicit-atom! (R result (parse-term e)))
                             result))
  (match e
    ('_                         (fresh-var))
    ((? symbol?)                (var e))
    ((list 'quote      c)       (constant c))
    ((list 'quasiquote qq)      (let parse-qq ((qq qq) (level 0))
                                  (match qq
                                    ((list 'unquote          e) (if (= level 0)
                                                                  (parse-term e)
                                                                  (build-list (constant 'unquote)
                                                                              (parse-qq e (- level 1)))))
                                    ((list 'quasiquote      qq) (build-list (constant 'quasiquote)
                                                                            (parse-qq qq (+ level 1))))
                                    ((cons 'quasiquote       _) (error "improper quasiquote"               qq e))
                                    ((cons 'unquote          _) (error "improper unquote"                  qq e))
                                    ((cons 'unquote-splicing _) (error "unquote-splicing is not supported" qq e))
                                    ((cons qq.a qq.d)           (build-cons (parse-qq qq.a level)
                                                                            (parse-qq qq.d level)))
                                    ((? vector?)                (error "quasiquoted vectors are not supported" qq))
                                    (_                          (constant qq)))))
    ((cons 'quote            _) (error "improper quote"             e))
    ((cons 'quasiquote       _) (error "improper quasiquote"        e))
    ((cons 'unquote          _) (error "misplaced unquote"          e))
    ((cons 'unquote-splicing _) (error "misplaced unquote-splicing" e))
    (`(type ,e)                 (let ((result (fresh-var)))
                                  (implicit-atom! (type== (parse-term e) result))
                                  result))
    (`(cons ,e.a ,e.d)          (build-cons (parse-term e.a) (parse-term e.d)))
    (`(list ,@e*)               (build-list (map parse-term e*)))
    (`(+ ,e.a ,e.b)             (let ((result (fresh-var)))
                                  (implicit-atom! (+== (parse-term e.a) (parse-term e.b) result))
                                  result))
    (`(- ,e.a ,e.b)             (let ((result (fresh-var)))
                                  (implicit-atom! (+== result (parse-term e.b) (parse-term e.a)))
                                  result))
    (`(* ,e.a ,e.b)             (let ((result (fresh-var)))
                                  (implicit-atom! (*== (parse-term e.a) (parse-term e.b) result))
                                  result))
    (`(/ ,e.a ,e.b)             (let ((result (fresh-var))
                                      (b      (parse-term e.b)))
                                  (implicit-atom! (=/= (constant 0) b))
                                  (implicit-atom! (*== result b (parse-term e.a)))
                                  result))
    (`(symbol->string ,e)       (build-l2r symbol-string e))
    (`(string->symbol ,e)       (build-r2l symbol-string e))
    (`(string->bytes  ,e)       (build-l2r string-bytes  e))
    (`(bytes->string  ,e)       (build-r2l string-bytes  e))
    (`(bytes->list    ,e)       (build-l2r bytes-list    e))
    (`(list->bytes    ,e)       (build-r2l bytes-list    e))
    (`(vector->list   ,e)       (build-l2r vector-list   e))
    (`(list->vector   ,e)       (build-r2l vector-list   e))
    ((cons _ _)                 (error "unsupported function call" e))
    ((? vector?)                (error "invalid term" e))
    (_                          (constant e))))

(define (parse-rule e)
  (parameterize ((current-fresh-variable 0)
                 (current-implicit-atoms '()))
    (let ((head (parse-atom (car e)))
          (body (let loop ((e* (cdr e)))
                  (match e*
                    ('()            '())
                    ((cons 'not e*) (map parse-negated-atom e*))
                    ((cons e    e*) (cons (parse-atom e) (loop e*)))))))
      (rule head (append body (current-implicit-atoms))))))

(define current-fresh-relation (make-parameter #f))
(define current-fresh-variable (make-parameter #f))
(define current-implicit-atoms (make-parameter #f))

(define (fresh-relation)
  (let ((name.next (current-fresh-relation)))
    (current-fresh-relation (+ name.next 1))
    (relation-generated name.next)))

(define (fresh-var)
  (let ((name.next (current-fresh-variable)))
    (current-fresh-variable (+ name.next 1))
    (var name.next)))

(define (implicit-atom! atom)
  (let ((implicit-atoms (current-implicit-atoms)))
    (unless implicit-atoms (error "implicit-atom! called outside of a parsing context"))
    (current-implicit-atoms (cons atom implicit-atoms))))

(define (rule-connected-components r)
  (define (atom-vars a) (list->set (map var-name (filter var? (atom-args a)))))
  (define (split-reachable a* vars.initial)
    (let retry ((a* a*) (a*.reached '()) (vars.initial vars.initial))
      (let loop ((a* a*) (a*.reached a*.reached) (a*.missed '()) (vars vars.initial))
        (match a*
          ('()         (if (equal? vars vars.initial)
                         (values a*.reached a*.missed)
                         (retry a*.missed a*.reached vars)))
          ((cons a a*) (let ((vars.a (atom-vars a)))
                         (if (set-empty? (set-intersect vars vars.a))
                           (loop a* a*.reached (cons a a*.missed) vars)
                           (loop a* (cons a a*.reached) a*.missed (set-union vars vars.a)))))))))
  (let-values (((a*.reached a*.missed) (split-reachable (rule-body r) (atom-vars (rule-head r)))))
    (if (null? a*.missed)
      (list r)
      (let ((a.factored (atom (fresh-relation) '())))
        (cons (rule (rule-head r) (cons a.factored a*.reached))
              (let retry ((a.head a.factored) (a* a*.missed))
                (let ((a0 (car a*)))
                  (let-values (((a*.reached a*.missed) (split-reachable (cdr a*) (atom-vars a0))))
                    (if (null? a*.missed)
                      (list (rule a.head (cons a0 a*.reached)))
                      (let ((a.factored (atom (fresh-relation) '())))
                        (cons (rule a.head (cons a.factored (cons a0 a*.reached)))
                              (retry a.factored a*.missed))))))))))))

(define (group x->key x->value xs)
  (foldl (lambda (x k=>v*) (hash-update k=>v* (x->key x) (lambda (v*) (cons (x->value x) v*)) '()))
         (hash) xs))

(define (stratify rules)
  (define (search r->r* r* seen)
    (let loop ((r* r*) (seen seen) (finished '()))
      (match r*
        ('()         (values seen finished))
        ((cons r r*) (if (set-member? seen r)
                       (loop r* seen finished)
                       (let-values (((seen finished) (loop (r->r* r) (set-add seen r) finished)))
                         (loop r* seen (cons r finished))))))))
  (define (atom-positive-relation     a) (let ((R (atom-relation a)))
                                           (if (relation-negation? R) (relation-negation-target R) R)))
  (define (rule-relation              r) (atom-relation (rule-head r)))
  (define (rule-relation-dependencies r) (set->list (list->set (map atom-positive-relation (rule-body r)))))
  (let ((R=>rule*       (group rule-relation (lambda (r) r) rules))
        (R=>dependents* (foldl (lambda (r R=>d*)
                                 (foldl (lambda (R R=>d*) (hash-update R=>d* R (lambda (d*) (cons r d*)) '()))
                                        R=>d* (rule-relation-dependencies r)))
                               (hash) rules)))
    (define (rule-rule-dependents   r) (hash-ref R=>dependents* (rule-relation r)))
    (define (rule-rule-dependencies r)
      (apply append (map (lambda (R) (hash-ref R=>rule* R '())) (rule-relation-dependencies r))))
    (let-values (((seen finished) (search rule-rule-dependencies rules (set))))
      (let loop ((r* finished) (seen (set)) (strata '()))
        (match r*
          ('() strata)
          ((cons r r*)
           (if (set-member? seen r)
             (loop r* seen strata)
             (let-values (((seen scc) (search rule-rule-dependents (list r) seen)))
               (let ((R* (list->set (map rule-relation scc))))
                 (for-each (lambda (r)
                             (for-each (lambda (R.neg)
                                         (when (set-member? R* (relation-negation-target R.neg))
                                           (error "cyclic rule dependency through negation"
                                                  (map relation-name (set->list R*)))))
                                       (filter relation-negation? (map atom-relation (rule-body r)))))
                           scc))
               (loop r* seen
                     (cons (cons (if (or (pair? (cdr scc))
                                         (member (rule-relation (car scc))
                                                 (rule-relation-dependencies (car scc))))
                                   'fixed-point 'once)
                                 scc)
                           strata))))))))))

(define (hash-map-values h f) (make-immutable-hash (hash-map h (lambda (k v) (cons k (f v))))))

(define R=>mode*.primitive
  (hash-map-values
    (hash prim.==            '((#f #t) (#t #f))
          prim.<             '((#t #t))
          prim.<=            '((#t #t))
          prim.type==        '((#t #f))
          prim.cons==        '((#t #t #f) (#f #f #t))
          prim.+==           '((#t #t #f) (#t #f #t) (#f #t #t))
          prim.*==           '((#t #t #f) (#t #f #t) (#f #t #t))
          prim.symbol-string '((#f #t) (#t #f))
          prim.string-bytes  '((#f #t) (#t #f))
          prim.bytes-list    '((#f #t) (#t #f))
          prim.vector-list   '((#f #t) (#t #f)))
    list->set))

(define (infer-modes rules R=>mode*)
  (let loop ((R=>mode*.initial R=>mode*))
    (let ((R=>mode* (foldl (lambda (r R=>mode*) (rule-infer-modes r R=>mode*))
                           R=>mode*.initial rules)))
      (if (equal? R=>mode* R=>mode*.initial)
        R=>mode*
        (loop R=>mode*)))))

(define (rule-infer-modes r R=>mode*)
  (define (consistent-arity?! mode len a)
    (unless (equal? (length mode) len)
      (error "relation arity mismatch" (relation-name (atom-relation a)) (length mode) len)))
  (let* ((head      (rule-head r))
         (body      (rule-body r))
         (vars.head (list->set (map var-name (filter var? (atom-args head)))))
         (R=>mode*  (if (hash-has-key? R=>mode* (atom-relation head))
                      R=>mode*
                      (let ((vars.body (list->set
                                         (foldl (lambda (a vars)
                                                  (foldl (lambda (t vars)
                                                           (if (var? t) (set-add vars (var-name t)) vars))
                                                         vars (atom-args a)))
                                                (set) body))))
                        (hash-set R=>mode* (atom-relation head)
                                  (list (map (lambda (t)
                                               (and (var? t) (not (set-member? vars.body (var-name t)))))
                                             (atom-args head))))))))
    (define (atom-mode* a) (let ((R (atom-relation a)))
                             (let ((m* (if (relation-negation? R)
                                         (list (map (lambda (x) #t) (atom-args a)))
                                         (hash-ref R=>mode* R
                                                   (lambda () (list (map (lambda (x) #f) (atom-args a)))))))
                                   (l  (length (atom-args a))))
                               (for-each (lambda (m) (consistent-arity?! m l a)) m*)
                               m*)))
    (define (search mode a* bound)
      (consistent-arity?! mode (length (atom-args head)) head)
      (let retry ((a* body) (bound.initial (foldl (lambda (bound? t bound)
                                                    (if (and bound? (var? t))
                                                      (set-add bound (var-name t))
                                                      bound))
                                                  bound mode (atom-args head))))
        (let loop ((a* a*) (a*.missed '()) (bound bound.initial))
          (match a*
            ('()
             (if (equal? bound bound.initial)
               (if (null? a*.missed)
                 (list mode)
                 (let* ((candidate? (lambda (t) (and (var? t) (not (set-member? bound (var-name t))))))
                        (candidates (lambda (a) (list->set (map var-name (filter candidate? (atom-args a))))))
                        (v**        (foldl (lambda (a v**) (let ((v* (candidates a)))
                                                             (if (subset? v* vars.head) (cons v* v**) v**)))
                                           '() a*.missed))
                        (v**.best   (foldl (lambda (v* v**.best)
                                             (if (ormap (lambda (v*.best) (subset? v*.best v*)) v**.best)
                                               v**.best
                                               (cons v* v**.best)))
                                           '() (sort v** (lambda (a b) (< (set-count a) (set-count b)))))))
                   (define (constrain v*)
                     (map (lambda (bound? t) (or bound? (and (var? t) (set-member? v* (var-name t)))))
                          mode (atom-args head)))
                   (apply append (map (lambda (v*) (search (constrain v*) a*.missed bound)) v**.best))))
               (retry a*.missed bound)))
            ((cons a a*)
             (let ((signature (map (lambda (t) (or (constant? t) (set-member? bound (var-name t))))
                                   (atom-args a))))
               (if (ormap (lambda (mode)
                            (andmap (lambda (b?.mode b?.sig) (or b?.sig (not b?.mode))) mode signature))
                          (atom-mode* a))
                 (loop a* a*.missed (set-union bound (list->set (map var-name (filter var? (atom-args a))))))
                 (loop a* (cons a a*.missed) bound))))))))
    (define (merge-modes mode*)
      (define (subsumes? m0 m1) (andmap (lambda (b0? b1?) (or b1? (not b0?))) m0 m1))
      (foldl (lambda (m mode*) (if (ormap (lambda (m0) (subsumes? m0 m)) mode*)
                                 mode*
                                 (cons m mode*)))
             '() mode*))
    (let ((m* (merge-modes (apply append (map (lambda (mode) (search mode body (set))) (atom-mode* head))))))
      (if (null? m*)
        (error "relation has no finite mode" (relation-name (atom-relation head)))
        (hash-set R=>mode* (atom-relation head) m*)))))
