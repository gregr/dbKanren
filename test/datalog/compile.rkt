#lang racket/base
(provide
  current-primitive-relations
  primitive-relations.base
  parse-rule)
(require racket/match racket/set)

(define (relation-name            R) (cadr R))
(define (relation-original?       R) (eq? (car R) 'orig))
(define (relation-original     name) (list 'orig name))

(define (relation-generated?      R) (eq? (car R) 'new))
(define (relation-generated    name) (list 'new  name))

(define (relation-primitive?      R) (eq? (car R) 'prim))
(define (relation-primitive    name) (list 'prim name))

(define (relation-negation?       R) (eq? (car R) 'not))
(define (relation-negation R.target) (list 'not  R.target))
(define (relation-negation-target R) (cadr R))

(define (atom        R args) (cons R args))
(define (atom-relation atom) (car atom))
(define (atom-args     atom) (cdr atom))

(define (var?           t) (eq? (car t) 'var))
(define (var         name) (list 'var   name))
(define (var-name       x) (cadr x))

(define (constant?      t) (eq? (car t) 'quote))
(define (constant   value) (list 'quote value))
(define (constant-value c) (eq? (car c) 'quote))

(define (rule head body) (cons head body))
(define (rule-head    r) (car r))
(define (rule-body    r) (cdr r))

(define prim.==              (relation-primitive '==))
(define prim.=/=             (relation-primitive '=/=))
(define prim.<               (relation-primitive '<))
(define prim.<=              (relation-primitive '<=))
(define prim.type==          (relation-primitive 'type==))
(define prim.cons==          (relation-primitive 'cons==))
(define prim.+==             (relation-primitive '+==))
(define prim.*==             (relation-primitive '*==))
(define prim.string-append== (relation-primitive 'string-append==))
(define prim.bytes-append==  (relation-primitive 'bytes-append==))

(define (==              t0 t1)            (atom prim.==              (list t0 t1)))
(define (=/=             t0 t1)            (atom prim.=/=             (list t0 t1)))
(define (type==          t       t.result) (atom prim.type==          (list t t.result)))
(define (cons==          t.a t.d t.result) (atom prim.cons==          (list t.a t.d t.result)))
(define (+==             t0  t1  t.result) (atom prim.+==             (list t0  t1  t.result)))
(define (*==             t0  t1  t.result) (atom prim.*==             (list t0  t1  t.result)))
(define (string-append== t0  t1  t.result) (atom prim.string-append== (list t0  t1  t.result)))
(define (bytes-append==  t0  t1  t.result) (atom prim.bytes-append==  (list t0  t1  t.result)))

(define primitive-relations.base
  (hash '==           ==
        '=/=          =/=
        '<            (lambda (t0 t1) (atom prim.<  (list t0 t1)))
        '<=           (lambda (t0 t1) (atom prim.<= (list t0 t1)))
        '>            (lambda (t0 t1) (atom prim.<  (list t1 t0)))
        '>=           (lambda (t0 t1) (atom prim.<= (list t1 t0)))))

(define current-primitive-relations (make-parameter (hash)))

(define (parse-fact         e) (atom (relation-original (car e)) (cdr e)))
(define (parse-atom         e) (atom (relation-original (car e)) (map parse-term (cdr e))))
(define (parse-negated-atom e) (let ((a (parse-atom e)))
                                 (atom (relation-negation (atom-relation a)) (atom-args a))))

(define (parse-term e)
  (define (build-cons a d) (let ((result (fresh-var)))
                             (implicit-atom! (cons== a d result))
                             result))
  (define (build-list ts)  (foldr build-cons (constant '()) ts))
  (match e
    ('_                         (fresh-var))
    ((? symbol?)                (var e))
    ((list 'quote      c)       (constant c))
    ((list 'quasiquote qq)      (let parse-qq ((qq qq) (level 0))
                                  (match qq
                                    ((list 'unquote          e) (if (= level 0)
                                                                  (parse-term e)
                                                                  (build-list (constant 'unquote)
                                                                              (parse-qq e (- level 1)))))
                                    ((list 'quasiquote      qq) (build-list (constant 'quasiquote)
                                                                            (parse-qq qq (+ level 1))))
                                    ((cons 'quasiquote       _) (error "improper quasiquote"               qq e))
                                    ((cons 'unquote          _) (error "improper unquote"                  qq e))
                                    ((cons 'unquote-splicing _) (error "unquote-splicing is not supported" qq e))
                                    ((cons qq.a qq.d)           (build-cons (parse-qq qq.a level)
                                                                            (parse-qq qq.d level)))
                                    ((? vector?)                (error "quasiquoted vectors are not supported" qq))
                                    (_                          (constant qq)))))
    ((cons 'quote            _) (error "improper quote"             e))
    ((cons 'quasiquote       _) (error "improper quasiquote"        e))
    ((cons 'unquote          _) (error "misplaced unquote"          e))
    ((cons 'unquote-splicing _) (error "misplaced unquote-splicing" e))
    (`(type ,e)                 (let ((result (fresh-var)))
                                  (implicit-atom! (type== (parse-term e) result))
                                  result))
    (`(cons ,e.a ,e.d)          (build-cons (parse-term e.a) (parse-term e.d)))
    (`(list ,@e*)               (build-list (map parse-term e*)))
    (`(+ ,e.a ,e.b)             (let ((result (fresh-var)))
                                  (implicit-atom! (+== (parse-term e.a) (parse-term e.b) result))
                                  result))
    (`(- ,e.a ,e.b)             (let ((result (fresh-var)))
                                  (implicit-atom! (+== result (parse-term e.b) (parse-term e.a)))
                                  result))
    (`(* ,e.a ,e.b)             (let ((result (fresh-var)))
                                  (implicit-atom! (*== (parse-term e.a) (parse-term e.b) result))
                                  result))
    (`(/ ,e.a ,e.b)             (let ((result (fresh-var))
                                      (b      (parse-term e.b)))
                                  (implicit-atom! (=/= (constant 0) b))
                                  (implicit-atom! (*== result b (parse-term e.a)))
                                  result))
    (`(string-append ,e.a ,e.b) (let ((result (fresh-var)))
                                  (implicit-atom! (string-append== (parse-term e.a) (parse-term e.b) result))
                                  result))
    (`(bytes-append ,e.a ,e.b)  (let ((result (fresh-var)))
                                  (implicit-atom! (bytes-append==  (parse-term e.a) (parse-term e.b) result))
                                  result))
    ((cons _ _)                 (error "unsupported function call" e))
    ((? vector?)                (error "invalid term" e))
    (_                          (constant e))))

(define (parse-rule e)
  (parameterize ((current-fresh-variable 0)
                 (current-implicit-atoms '()))
    (let ((head (parse-atom (car e)))
          (body (let loop ((e* (cdr e)))
                  (match e*
                    ('()            '())
                    ((cons 'not e*) (map parse-negated-atom e*))
                    ((cons e    e*) (cons (parse-atom e) (loop e*)))))))
      (rule head (append body (current-implicit-atoms))))))

(define current-fresh-relation (make-parameter #f))
(define current-fresh-variable (make-parameter #f))
(define current-implicit-atoms (make-parameter #f))

(define (fresh-relation)
  (let ((name.next (current-fresh-relation)))
    (current-fresh-relation (+ name.next 1))
    (relation-generated name.next)))

(define (fresh-var)
  (let ((name.next (current-fresh-variable)))
    (current-fresh-variable (+ name.next 1))
    (var name.next)))

(define (implicit-atom! atom)
  (let ((implicit-atoms (current-implicit-atoms)))
    (unless implicit-atoms (error "implicit-atom! called outside of a parsing context"))
    (current-implicit-atoms (cons atom implicit-atoms))))

(define (rule-connected-components r)
  (define (atom-vars a) (list->set (map var-name (filter var? (atom-args a)))))
  (define (split-reachable a* vars.initial)
    (let retry ((a* a*) (a*.reached '()) (vars.initial vars.initial))
      (let loop ((a* a*) (a*.reached a*.reached) (a*.missed '()) (vars vars.initial))
        (match a*
          ('()         (if (equal? vars vars.initial)
                         (values a*.reached a*.missed)
                         (retry a*.missed a*.reached vars)))
          ((cons a a*) (let ((vars.a (atom-vars a)))
                         (if (set-empty? (set-intersect vars vars.a))
                           (loop a* a*.reached (cons a a*.missed) vars)
                           (loop a* (cons a a*.reached) a*.missed (set-union vars vars.a)))))))))
  (let-values (((a*.reached a*.missed) (split-reachable (rule-body r) (atom-vars (rule-head r)))))
    (if (null? a*.missed)
      (list r)
      (let ((a.factored (atom (fresh-relation) '())))
        (cons (rule (rule-head r) (cons a.factored a*.reached))
              (let retry ((a.head a.factored) (a* a*.missed))
                (let ((a0 (car a*)))
                  (let-values (((a*.reached a*.missed) (split-reachable (cdr a*) (atom-vars a0))))
                    (if (null? a*.missed)
                      (list (rule a.head (cons a0 a*.reached)))
                      (let ((a.factored (atom (fresh-relation) '())))
                        (cons (rule a.head (cons a.factored (cons a0 a*.reached)))
                              (retry a.factored a*.missed))))))))))))

(define (stratify rules)
  (define (search r->r* r* seen)
    (let loop ((r* r*) (seen seen) (finished '()))
      (match r*
        ('()         (values seen finished))
        ((cons r r*) (if (set-member? seen r)
                       (loop r* seen finished)
                       (let-values (((seen finished) (loop (r->r* r) (set-add seen r) finished)))
                         (loop r* seen (cons r finished))))))))
  (define (atom-positive-relation     a) (let ((R (atom-relation a)))
                                           (if (relation-negation? R) (relation-negation-target R) R)))
  (define (rule-relation              r) (atom-relation (rule-head r)))
  (define (rule-relation-dependencies r) (set->list (list->set (map atom-positive-relation (rule-body r)))))
  (let ((R=>rule*       (group rule-relation (lambda (r) r) rules))
        (R=>dependents* (foldl (lambda (r R=>d*)
                                 (foldl (lambda (R R=>d*) (hash-update R=>d* R (lambda (d*) (cons r d*)) '()))
                                        R=>d* (rule-relation-dependencies r)))
                               (hash) rules)))
    (define (rule-rule-dependents   r) (hash-ref R=>dependents* (rule-relation r)))
    (define (rule-rule-dependencies r)
      (apply append (map (lambda (R) (hash-ref R=>rule* R '())) (rule-relation-dependencies r))))
    (let-values (((seen finished) (search rule-rule-dependencies rules (set))))
      (let loop ((r* finished) (seen (set)) (strata '()))
        (match r*
          ('() strata)
          ((cons r r*)
           (if (set-member? seen r)
             (loop r* seen strata)
             (let-values (((seen scc) (search rule-rule-dependents (list r) seen)))
               (let ((R* (list->set (map rule-relation scc))))
                 (for-each (lambda (r)
                             (for-each (lambda (R.neg)
                                         (when (set-member? R* (relation-negation-target R.neg))
                                           (error "cyclic rule dependency through negation"
                                                  (map relation-name (set->list R*)))))
                                       (filter relation-negation? (map atom-relation (rule-body r)))))
                           scc))
               (loop r* seen
                     (cons (cons (if (or (pair? (cdr scc))
                                         (member (rule-relation (car scc))
                                                 (rule-relation-dependencies (car scc))))
                                   'fixed-point 'once)
                                 scc)
                           strata))))))))))
