#lang racket/base
(provide
  current-primitive-relations
  primitive-relations.base
  parse-rule)
(require racket/match)

(define (relation-original?       R) (eq? (car R) 'orig))
(define (relation-original     name) (list 'orig name))

(define (relation-generated?      R) (eq? (car R) 'new))
(define (relation-generated    name) (list 'new  name))

(define (relation-primitive?      R) (eq? (car R) 'prim))
(define (relation-primitive    name) (list 'prim name))
(define (relation-primitive-name  R) (cadr R))

(define (relation-negation?       R) (eq? (car R) 'not))
(define (relation-negation R.target) (list 'not  R.target))
(define (relation-negation-target R) (cadr R))

(define (atom        R args) (cons R args))
(define (atom-relation atom) (car atom))
(define (atom-args     atom) (cdr atom))

(define (var?           t) (eq? (car t) 'var))
(define (var         name) (list 'var   name))
(define (var-name       x) (cadr x))

(define (constant?      t) (eq? (car t) 'quote))
(define (constant   value) (list 'quote value))
(define (constant-value c) (eq? (car c) 'quote))

(define (rule head body) (cons head body))
(define (rule-head    r) (car r))
(define (rule-body    r) (cdr r))

(define prim.==              (relation-primitive '==))
(define prim.=/=             (relation-primitive '=/=))
(define prim.<               (relation-primitive '<))
(define prim.<=              (relation-primitive '<=))
(define prim.type==          (relation-primitive 'type==))
(define prim.cons==          (relation-primitive 'cons==))
(define prim.+==             (relation-primitive '+==))
(define prim.*==             (relation-primitive '*==))
(define prim.string-append== (relation-primitive 'string-append==))
(define prim.bytes-append==  (relation-primitive 'bytes-append==))

(define (==              t0 t1)            (atom prim.==              (list t0 t1)))
(define (=/=             t0 t1)            (atom prim.=/=             (list t0 t1)))
(define (type==          t       t.result) (atom prim.type==          (list t t.result)))
(define (cons==          t.a t.d t.result) (atom prim.cons==          (list t.a t.d t.result)))
(define (+==             t0  t1  t.result) (atom prim.+==             (list t0  t1  t.result)))
(define (*==             t0  t1  t.result) (atom prim.*==             (list t0  t1  t.result)))
(define (string-append== t0  t1  t.result) (atom prim.string-append== (list t0  t1  t.result)))
(define (bytes-append==  t0  t1  t.result) (atom prim.bytes-append==  (list t0  t1  t.result)))

(define primitive-relations.base
  (hash '==           ==
        '=/=          =/=
        '<            (lambda (t0 t1) (atom prim.<  (list t0 t1)))
        '<=           (lambda (t0 t1) (atom prim.<= (list t0 t1)))
        '>            (lambda (t0 t1) (atom prim.<  (list t1 t0)))
        '>=           (lambda (t0 t1) (atom prim.<= (list t1 t0)))))

(define current-primitive-relations (make-parameter (hash)))

(define (parse-fact         e) (atom (relation-original (car e)) (cdr e)))
(define (parse-atom         e) (atom (relation-original (car e)) (map parse-term (cdr e))))
(define (parse-negated-atom e) (let ((a (parse-atom e)))
                                 (atom (relation-negation (atom-relation a)) (atom-args a))))

(define (parse-term e)
  (define (build-cons a d) (let ((result (fresh-var)))
                             (implicit-atom! (cons== a d result))
                             result))
  (define (build-list ts)  (foldr build-cons (constant '()) ts))
  (match e
    ('_                         (fresh-var))
    ((? symbol?)                (var e))
    ((list 'quote      c)       (constant c))
    ((list 'quasiquote qq)      (let parse-qq ((qq qq) (level 0))
                                  (match qq
                                    ((list 'unquote          e) (if (= level 0)
                                                                  (parse-term e)
                                                                  (build-list (constant 'unquote)
                                                                              (parse-qq e (- level 1)))))
                                    ((list 'quasiquote      qq) (build-list (constant 'quasiquote)
                                                                            (parse-qq qq (+ level 1))))
                                    ((cons 'quasiquote       _) (error "improper quasiquote"               qq e))
                                    ((cons 'unquote          _) (error "improper unquote"                  qq e))
                                    ((cons 'unquote-splicing _) (error "unquote-splicing is not supported" qq e))
                                    ((cons qq.a qq.d)           (build-cons (parse-qq qq.a level)
                                                                            (parse-qq qq.d level)))
                                    ((? vector?)                (error "quasiquoted vectors are not supported" qq))
                                    (_                          (constant qq)))))
    ((cons 'quote            _) (error "improper quote"             e))
    ((cons 'quasiquote       _) (error "improper quasiquote"        e))
    ((cons 'unquote          _) (error "misplaced unquote"          e))
    ((cons 'unquote-splicing _) (error "misplaced unquote-splicing" e))
    (`(type ,e)                 (let ((result (fresh-var)))
                                  (implicit-atom! (type== (parse-term e) result))
                                  result))
    (`(cons ,e.a ,e.d)          (build-cons (parse-term e.a) (parse-term e.d)))
    (`(list ,@e*)               (build-list (map parse-term e*)))
    (`(+ ,e.a ,e.b)             (let ((result (fresh-var)))
                                  (implicit-atom! (+== (parse-term e.a) (parse-term e.b) result))
                                  result))
    (`(- ,e.a ,e.b)             (let ((result (fresh-var)))
                                  (implicit-atom! (+== result (parse-term e.b) (parse-term e.a)))
                                  result))
    (`(* ,e.a ,e.b)             (let ((result (fresh-var)))
                                  (implicit-atom! (*== (parse-term e.a) (parse-term e.b) result))
                                  result))
    (`(/ ,e.a ,e.b)             (let ((result (fresh-var))
                                      (b      (parse-term e.b)))
                                  (implicit-atom! (=/= (constant 0) b))
                                  (implicit-atom! (*== result b (parse-term e.a)))
                                  result))
    (`(string-append ,e.a ,e.b) (let ((result (fresh-var)))
                                  (implicit-atom! (string-append== (parse-term e.a) (parse-term e.b) result))
                                  result))
    (`(bytes-append ,e.a ,e.b)  (let ((result (fresh-var)))
                                  (implicit-atom! (bytes-append==  (parse-term e.a) (parse-term e.b) result))
                                  result))
    ((cons _ _)                 (error "unsupported function call" e))
    ((? vector?)                (error "invalid term" e))
    (_                          (constant e))))

(define (parse-rule e)
  (parameterize ((current-fresh-variable 0)
                 (current-implicit-atoms '()))
    (let ((head (parse-atom (car e)))
          (body (let loop ((e* (cdr e)))
                  (match e*
                    ('()            '())
                    ((cons 'not e*) (map parse-negated-atom e*))
                    ((cons e    e*) (cons (parse-atom e) (loop e*)))))))
      (rule head (append body (current-implicit-atoms))))))

(define current-fresh-variable (make-parameter #f))
(define current-implicit-atoms (make-parameter #f))

(define (fresh-var)
  (let ((name.next (current-fresh-variable)))
    (current-fresh-variable (+ name.next 1))
    (var name.next)))

(define (implicit-atom! atom)
  (let ((implicit-atoms (current-implicit-atoms)))
    (unless implicit-atoms (error "implicit-atom! called outside of a parsing context"))
    (current-implicit-atoms (cons atom implicit-atoms))))
