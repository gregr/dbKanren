#lang racket/base
(provide
  column-describe
  column-count
  column-ref
  column-ref*
  column-slice
  column-group
  column-group/key?
  column-group/key
  column-sorted-group/key
  column-group/key*
  column-sorted-group/key*
  column:encoding.int
  column:encoding.text
  column:ref/class-name
  column:ref.int
  column:ref.text
  column:vector/class-name
  column:vector.int
  column:vector.text
  group-map
  group-filter
  )
(require (for-syntax racket/base) racket/fixnum racket/vector)
(require
  "../dbk/safe-unsafe.rkt"
  ;racket/unsafe/ops
  )

(define (column-describe          col) (col 'describe))
(define (column-count             col) (col 'count))
;; i -> x
(define (column-ref               col) (col 'ref))
;; start end -> (yield! x span.start span.end)
(define (column-group             col) (col 'group))
;; key* -> start end -> (yield! key span.start span.end)
(define (column-group/key*        col) (col 'group/key*))
;; key* -> start end -> (yield! key insertion-and-span.start span.end)
;; - with sorted-group/key*, if a key is not present, it will still be yielded, but its
;;   span.start and span.end will be equal
(define (column-sorted-group/key* col) (col 'sorted-group/key*))
;; key -> start end -> (yield! key span.start span.end)
(define (column-group/key col)
  (let ((group/key* (column-group/key* col)))
    (lambda (key) (group/key* (vector key)))))
;; key -> start end -> (yield! key insertion-and-span.start span.end)
(define (column-sorted-group/key col)
  (let ((sorted-group/key* (column-sorted-group/key* col)))
    (lambda (key) (sorted-group/key* (vector key)))))
;; key? -> start end -> (yield! key span.start span.end)
(define (column-group/key? col)
  (let ((group (column-group col)))
    (lambda (key?) (lambda (start end) (group-filter (group start end) key?)))))
;; i* -> x*
(define (column-ref* col)
  (let ((ref (column-ref col)))
    (lambda (i* count)
      (let ((x* (make-vector count)))
        (let loop ((i 0))
          (when (unsafe-fx< i count)
            (unsafe-vector*-set! x* i (ref (unsafe-fxvector-ref i* i)))
            (loop (unsafe-fx+ i 1))))
        x*))))
;; start end -> x*
(define (column-slice col)
  (let ((group (column-group col)))
    (lambda (start end)
      (let ((x* (make-vector (unsafe-fx- end start))) (i 0))
        ((group start end)
         (lambda (x span.start span.end)
           (let loop ((count (unsafe-fx- span.end span.start)))
             (when (unsafe-fx< 0 count)
               (unsafe-vector*-set! x* i x)
               (set! i (unsafe-fx+ i 1))
               (loop (unsafe-fx- count 1))))))
        x*))))

(define (min-bits n)
  (let loop ((n n))
    (if (< 0 n) (+ 1 (loop (fxrshift n 1))) 0)))
(define (min-bytes n)
  (let ((bits (min-bits n)))
    (+ (quotient bits 8) (if (= 0 (remainder bits 8)) 0 1))))
(define (nat-min-byte-width nat.max) (max (min-bytes nat.max) 1))
(define (bit-width->int-min  bit-width)  (unsafe-fx- (unsafe-fxlshift 1 (unsafe-fx- bit-width 1))))
(define (byte-width->int-min byte-width) (bit-width->int-min (unsafe-fxlshift byte-width 3)))

;(define-syntax (define-inline stx)
;  (syntax-case stx ()
;    ((_ (name param ...) body ...)
;     (with-syntax (((E.param ...) (generate-temporaries #'(param ...))))
;       #'(define-syntax-rule (name E.param ...)
;           (let ((param E.param) ...) body ...))))))
(define 1-unrolled-unsafe-bytes-nat-ref unsafe-bytes-ref)
(define (2-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fxior (unsafe-fxlshift (unsafe-bytes-ref bs             i)     8)
                (unsafe-bytes-ref                  bs (unsafe-fx+ i 1))))
(define (3-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fxior (unsafe-fxlshift (unsafe-bytes-ref bs             i)    16)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 1))  8)
                (unsafe-bytes-ref                  bs (unsafe-fx+ i 2))))
(define (4-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fxior (unsafe-fxlshift (unsafe-bytes-ref bs             i)    24)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 1)) 16)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 2))  8)
                (unsafe-bytes-ref                  bs (unsafe-fx+ i 3))))
(define (5-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fxior (unsafe-fxlshift (unsafe-bytes-ref bs             i)    32)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 1)) 24)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 2)) 16)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 3))  8)
                (unsafe-bytes-ref                  bs (unsafe-fx+ i 4))))
(define (6-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fxior (unsafe-fxlshift (unsafe-bytes-ref bs             i)    40)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 1)) 32)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 2)) 24)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 3)) 16)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 4))  8)
                (unsafe-bytes-ref                  bs (unsafe-fx+ i 5))))
(define (7-unrolled-unsafe-bytes-nat-ref bs i)
  (unsafe-fxior (unsafe-fxlshift (unsafe-bytes-ref bs             i)    48)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 1)) 40)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 2)) 32)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 3)) 24)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 4)) 16)
                (unsafe-fxlshift (unsafe-bytes-ref bs (unsafe-fx+ i 5))  8)
                (unsafe-bytes-ref                  bs (unsafe-fx+ i 6))))
(define (unsafe-bytes-nat-ref/width width bs i)
  (case width
    ((1)  (1-unrolled-unsafe-bytes-nat-ref bs i))
    ((2)  (2-unrolled-unsafe-bytes-nat-ref bs i))
    ((3)  (3-unrolled-unsafe-bytes-nat-ref bs i))
    ((4)  (4-unrolled-unsafe-bytes-nat-ref bs i))
    ((5)  (5-unrolled-unsafe-bytes-nat-ref bs i))
    ((6)  (6-unrolled-unsafe-bytes-nat-ref bs i))
    (else (7-unrolled-unsafe-bytes-nat-ref bs i))))
(define 1-unrolled-unsafe-bytes-nat-set! unsafe-bytes-set!)
(define (2-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 n)))
(define (3-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 16)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 2) (unsafe-fxand 255 n)))
(define (4-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 24)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 (unsafe-fxrshift n 16)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 2) (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 3) (unsafe-fxand 255 n)))
(define (5-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 32)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 (unsafe-fxrshift n 24)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 2) (unsafe-fxand 255 (unsafe-fxrshift n 16)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 3) (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 4) (unsafe-fxand 255 n)))
(define (6-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 40)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 (unsafe-fxrshift n 32)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 2) (unsafe-fxand 255 (unsafe-fxrshift n 24)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 3) (unsafe-fxand 255 (unsafe-fxrshift n 16)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 4) (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 5) (unsafe-fxand 255 n)))
(define (7-unrolled-unsafe-bytes-nat-set! bs i n)
  (unsafe-bytes-set! bs i                (unsafe-fxand 255 (unsafe-fxrshift n 48)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 1) (unsafe-fxand 255 (unsafe-fxrshift n 40)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 2) (unsafe-fxand 255 (unsafe-fxrshift n 32)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 3) (unsafe-fxand 255 (unsafe-fxrshift n 24)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 4) (unsafe-fxand 255 (unsafe-fxrshift n 16)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 5) (unsafe-fxand 255 (unsafe-fxrshift n 8)))
  (unsafe-bytes-set! bs (unsafe-fx+ i 6) (unsafe-fxand 255 n)))
(define (unsafe-bytes-nat-set!/width width bs i n)
  (case width
    ((1)  (1-unrolled-unsafe-bytes-nat-set! bs i n))
    ((2)  (2-unrolled-unsafe-bytes-nat-set! bs i n))
    ((3)  (3-unrolled-unsafe-bytes-nat-set! bs i n))
    ((4)  (4-unrolled-unsafe-bytes-nat-set! bs i n))
    ((5)  (5-unrolled-unsafe-bytes-nat-set! bs i n))
    ((6)  (6-unrolled-unsafe-bytes-nat-set! bs i n))
    (else (7-unrolled-unsafe-bytes-nat-set! bs i n))))

(define (unsafe-bytes-int-ref/width width bs i)
  (unsafe-fx+ (unsafe-bytes-nat-ref/width width bs i) (byte-width->int-min width)))
(define (unsafe-bytes-int-set!/width width bs i z)
  (unsafe-bytes-nat-set!/width width bs i (unsafe-fx- z (byte-width->int-min width))))

(define (unsafe-bytes=? a b)
  (let ((len (unsafe-bytes-length a)))
    (and (unsafe-fx= (unsafe-bytes-length b) len)
         (let loop ((i 0))
           (or (unsafe-fx= i len)
               (and (unsafe-fx= (unsafe-bytes-ref a i) (unsafe-bytes-ref b i))
                    (loop (unsafe-fx+ i 1))))))))
(define (unsafe-bytes<? a b)
  (let* ((len.a (unsafe-bytes-length a))
         (len.b (unsafe-bytes-length b))
         (end   (unsafe-fxmin len.a len.b)))
    (let loop ((i 0))
      (if (unsafe-fx= i end)
          (unsafe-fx< len.a len.b)
          (let ((x.a (unsafe-bytes-ref a i)) (x.b (unsafe-bytes-ref b i)))
            (or (unsafe-fx< x.a x.b)
                (and (unsafe-fx= x.a x.b) (loop (unsafe-fx+ i 1)))))))))
(define (unsafe-bytes-prefix? x prefix)
  (let ((len.prefix (unsafe-bytes-length prefix)))
    (and (unsafe-fx<= len.prefix (unsafe-bytes-length x))
         (let loop ((i 0))
           (or (unsafe-fx= i len.prefix)
               (and (unsafe-fx= (unsafe-bytes-ref x i) (unsafe-bytes-ref prefix i))
                    (loop (unsafe-fx+ i 1))))))))

(define (unsafe-bisect-skip start end <?)
  (let ((i (unsafe-fx- start 1)))
    (let loop ((offset 1))
      (let ((next (unsafe-fx+ i offset)))
        (if (and (unsafe-fx< next end) (<? next))
            (loop (unsafe-fxlshift offset 1))
            (let loop ((i i) (o offset))
              (let* ((o    (unsafe-fxrshift o 1))
                     (next (unsafe-fx+ i o)))
                (cond ((eq? o 0)                             (unsafe-fx+ i 1))
                      ((and (unsafe-fx< next end) (<? next)) (loop next o))
                      (else                                  (loop i    o))))))))))

(define ((group-map    enum f) yield!) (enum (lambda (x start end) (yield! (f x) start end))))
(define ((group-filter enum ?) yield!) (enum (lambda (x start end)
                                               (when (? x) (yield! x start end)))))
(define ((sorted-group/key*/i<x?&i=x? i<x? i=x?) key*)
  (let ((len (unsafe-vector*-length key*)))
    (lambda (start end)
      (lambda (yield!)
        (let loop ((i 0) (start start))
          (when (unsafe-fx< i len)
            (let* ((key (unsafe-vector*-ref key* i)))
              (let* ((span.start (unsafe-bisect-skip start      end (lambda (j) (i<x? j key))))
                     (span.end   (unsafe-bisect-skip span.start end (lambda (j) (i=x? j key)))))
                (yield! key span.start span.end)
                (loop (unsafe-fx+ i 1) span.end)))))))))
(define ((group/single-value single-value) start end)
  (if (unsafe-fx< start end)
      (lambda (yield!) (yield! single-value start end))
      (lambda (yield!) (void))))
(define ((group/key*/single-value single-value x=x?) key*)
  (let ((len (unsafe-vector*-length key*)))
    (let loop ((i 0))
      (if (unsafe-fx< i len)
          (if (x=x? (unsafe-vector*-ref key* i) single-value)
              (lambda (start end)
                (if (unsafe-fx< start end)
                    (lambda (yield!) (yield! single-value start end))
                    (lambda (yield!) (void))))
              (loop (unsafe-fx+ i 1)))
          (lambda (start end) (lambda (yield!) (void)))))))
(define ((((sorted-group/key*/single-value single-value x<x? x=x?) key*) start end) yield!)
  (let ((len (unsafe-vector*-length key*)))
    (let loop ((i 0))
      (when (unsafe-fx< i len)
        (let ((key (unsafe-vector*-ref key* i)))
          (if (x<x? key single-value)
              (begin (yield! key start start) (loop (unsafe-fx+ i 1)))
              (begin (if (x=x? key single-value)
                         (yield! key start end)
                         (yield! key end end))
                     (let loop ((i (unsafe-fx+ i 1)))
                       (when (unsafe-fx< i len)
                         (yield! (unsafe-vector*-ref key* i) end end)
                         (loop (unsafe-fx+ i 1)))))))))))
(define ((group/key*/group group x=x?) key*)
  (let* ((len (unsafe-vector*-length key*))
         (?   (lambda (x)
                (let loop ((i 0))
                  (and (unsafe-fx< i len)
                       (or (x=x? (unsafe-vector*-ref key* i) x)
                           (loop (unsafe-fx+ i 1))))))))
    (lambda (start end) (group-filter (group start end) ?))))

(define ((controller:missing-method class-name) method) (error "unknown method" class-name method))
(define ((controller:column super count describe ref group group/key* sorted-group/key*) method)
  (case method
    ((ref)               ref)
    ((group)             group)
    ((group/key*)        group/key*)
    ((sorted-group/key*) sorted-group/key*)
    ((count)             count)
    ((describe)          (describe))
    (else                (super method))))

(define (controller:column/array ref x=x? i=x? i<x? class-name count describe)
  (define ((group start end) yield!)
    (when (unsafe-fx< start end)
      (let loop ((start start) (x.current (ref start)))
        (let group ((i (unsafe-fx+ start 1)))
          (if (unsafe-fx< i end)
              (if (i=x? i x.current)
                  (group (unsafe-fx+ i 1))
                  (begin (yield! x.current start i)
                         (loop i (ref i))))
              (yield! x.current start i))))))
  (define group/key* (group/key*/group group x=x?))
  (define sorted-group/key* (sorted-group/key*/i<x?&i=x? i<x? i=x?))
  (controller:column (controller:missing-method class-name) count describe ref group group/key*
                     sorted-group/key*))

;; 4 bits for the encoding tag
;; 4 bits to describe a bit width
(define encoding.int:nat                0)
;; - the embedded bit width describes the codes
(define encoding.int:int                1)
;; - the embedded bit width describes the codes
(define encoding.int:frame-of-reference 2)
;; - the embedded bit width describes the codes, not the base
;; - another bit width is needed to describe the base
(define encoding.int:dictionary         3)
;; - the embedded bit width describes the dictionary count
(define encoding.int:run-length         4)
;; - the embedded bit width describes the run count
(define encoding.int:single-value       5)
;; - the embedded bit width describes the single value
(define encoding.int:delta-single-value 6)
;; - the embedded bit width describes the starting value, not the delta value
;; - another bit width is needed to describe the delta value

;; 4 bits for the encoding tag
;; 4 bits to describe a bit width
(define encoding.text:raw           0)
;; - the embedded bit width is ignored
(define encoding.text:dictionary    1)
;; - the embedded bit width describes the dictionary count
(define encoding.text:run-length    2)
;; - the embedded bit width describes the run count
(define encoding.text:single-value  3)
;; - the embedded bit width describes the length of the single value
(define encoding.text:single-prefix 4)
;; - the embedded bit width describes the length of the prefix
(define encoding.text:multi-prefix  5)
;; - the embedded bit width describes the prefix count

(define (column:encoding.int bv start.bv count)
  (let-values (((col end) (column:encoding.int&end bv start.bv count))) col))
(define (column:encoding.text bv start.bv count)
  (let-values (((col end) (column:encoding.text&end bv start.bv count))) col))

(define (column:encoding.int&end bv start.bv count)
  (let* ((pos.bv     start.bv)
         (encoding   (unsafe-bytes-ref bv pos.bv))
         (byte-width (unsafe-fxand encoding                     #b0111))
         (encoding   (unsafe-fxand (unsafe-fxrshift encoding 4) #b1111))
         (pos.bv     (unsafe-fx+ pos.bv 1)))
    (define (? x) (eq? encoding x))
    (cond
      ((? encoding.int:nat) (values (column:encoding.int:nat byte-width bv pos.bv count)
                                    (unsafe-fx+ (unsafe-fx* count byte-width) pos.bv)))
      ((? encoding.int:int) (values (column:encoding.int:int byte-width bv pos.bv count)
                                    (unsafe-fx+ (unsafe-fx* count byte-width) pos.bv)))
      ((? encoding.int:frame-of-reference)
       (let* ((byte-width.min (unsafe-bytes-ref bv pos.bv))
              (pos.bv         (unsafe-fx+ pos.bv 1))
              (z.min          (unsafe-bytes-int-ref/width byte-width.min bv pos.bv))
              (pos.bv         (unsafe-fx+ pos.bv byte-width.min)))
         (values (column:encoding.int:frame-of-reference z.min byte-width bv pos.bv count)
                 (unsafe-fx+ (unsafe-fx* count byte-width) pos.bv))))
      ((? encoding.int:dictionary)
       (let* ((count.dict (unsafe-bytes-nat-ref/width byte-width bv pos.bv))
              (pos.bv     (unsafe-fx+ pos.bv byte-width)))
         (let*-values (((col.dict pos.bv) (column:encoding.int&end bv pos.bv count.dict))
                       ((col.code pos.bv) (column:encoding.int&end bv pos.bv count)))
           (values (column:encoding.int:dictionary col.dict count.dict col.code count)
                   pos.bv))))
      ((? encoding.int:run-length)
       (let* ((count.run (unsafe-bytes-nat-ref/width byte-width bv pos.bv))
              (pos.bv    (unsafe-fx+ pos.bv byte-width)))
         (let*-values (((col.pos pos.bv) (column:encoding.int&end bv pos.bv (unsafe-fx+ count.run 1)))
                       ((col.run pos.bv) (column:encoding.int&end bv pos.bv count.run)))
           (values (column:encoding.int:run-length col.pos col.run count.run count)
                   pos.bv))))
      ((? encoding.int:single-value)
       (let ((single-value (unsafe-bytes-nat-ref/width byte-width bv pos.bv)))
         (values (column:encoding.int:single-value single-value count)
                 (unsafe-fx+ pos.bv byte-width))))
      ((? encoding.int:delta-single-value)
       (let* ((z.start          (unsafe-bytes-int-ref/width byte-width bv pos.bv))
              (pos.bv           (unsafe-fx+ pos.bv byte-width))
              (byte-width.delta (unsafe-bytes-ref bv pos.bv))
              (z.delta          (unsafe-bytes-int-ref/width byte-width.delta bv pos.bv)))
         (values (column:encoding.int:delta-single-value z.start z.delta count)
                 (unsafe-fx+ pos.bv byte-width.delta))))
      (else (error "unknown integer encoding" encoding)))))

(define (column:encoding.text&end bv start.bv count)
  (let* ((pos.bv     start.bv)
         (encoding   (unsafe-bytes-ref bv pos.bv))
         (byte-width (unsafe-fxand encoding                     #b0111))
         (encoding   (unsafe-fxand (unsafe-fxrshift encoding 4) #b1111))
         (pos.bv     (unsafe-fx+ pos.bv 1)))
    (define (? x) (eq? encoding x))
    (cond
      ((? encoding.text:raw)
       (let-values (((col.pos pos.bv) (column:encoding.int&end bv pos.bv (unsafe-fx+ count 1))))
         (values (column:encoding.text:raw col.pos bv pos.bv count)
                 ((column-ref col.pos) count))))
      ((? encoding.text:dictionary)
       (let* ((count.dict (unsafe-bytes-nat-ref/width byte-width bv pos.bv))
              (pos.bv     (unsafe-fx+ pos.bv byte-width)))
         (let*-values (((col.dict pos.bv) (column:encoding.text&end bv pos.bv count.dict))
                       ((col.code pos.bv) (column:encoding.int&end  bv pos.bv count)))
           (values (column:encoding.text:dictionary col.dict count.dict col.code count)
                   pos.bv))))
      ((? encoding.text:run-length)
       (let* ((count.run (unsafe-bytes-nat-ref/width byte-width bv pos.bv))
              (pos.bv    (unsafe-fx+ pos.bv byte-width)))
         (let*-values (((col.pos pos.bv) (column:encoding.int&end bv pos.bv (unsafe-fx+ count.run 1)))
                       ((col.run pos.bv) (column:encoding.text&end bv pos.bv count.run)))
           (values (column:encoding.text:run-length col.pos col.run count.run count)
                   pos.bv))))
      ((? encoding.text:single-value)
       (let* ((len.single-value (unsafe-bytes-nat-ref/width byte-width bv pos.bv))
              (pos.bv           (unsafe-fx+ pos.bv byte-width))
              (single-value     (let ((t (make-bytes len.single-value)))
                                  (unsafe-bytes-copy! t 0 bv pos.bv
                                                      (unsafe-fx+ pos.bv len.single-value))
                                  t)))
         (values (column:encoding.text:single-value single-value count)
                 (unsafe-fx+ pos.bv len.single-value))))
      ((? encoding.text:single-prefix)
       (let* ((len.single-prefix (unsafe-bytes-nat-ref/width byte-width bv pos.bv))
              (pos.bv            (unsafe-fx+ pos.bv byte-width))
              (single-prefix     (let ((t (make-bytes len.single-prefix)))
                                   (unsafe-bytes-copy! t 0 bv pos.bv
                                                       (unsafe-fx+ pos.bv len.single-prefix))
                                   t))
              (pos.bv            (unsafe-fx+ pos.bv len.single-prefix)))
         (let-values (((col.suffix pos.bv) (column:encoding.text&end bv pos.bv count)))
           (values (column:encoding.text:single-prefix single-prefix col.suffix count)
                   pos.bv))))
      ((? encoding.text:multi-prefix)
       (let* ((count.prefix (unsafe-bytes-nat-ref/width byte-width bv pos.bv))
              (pos.bv       (unsafe-fx+ pos.bv byte-width)))
         (let*-values (((col.prefix pos.bv) (column:encoding.text&end bv pos.bv count.prefix))
                       ((col.suffix pos.bv) (column:encoding.text&end bv pos.bv count)))
           (values (column:encoding.text:multi-prefix col.prefix count.prefix col.suffix count)
                   pos.bv))))
      (else (error "unknown text encoding" encoding)))))

(define (column:encoding.int:nat byte-width bv start.bv count)
  (column:encoding.int:frame-of-reference 0 byte-width bv start.bv count))

(define (column:encoding.int:int byte-width bv start.bv count)
  (column:encoding.int:frame-of-reference (byte-width->int-min byte-width) byte-width bv start.bv
                                          count))

(define (column:encoding.int:frame-of-reference z.min byte-width bv start.bv count)
  (define (describe)
    (let ((size.bv (- (unsafe-fx+ (unsafe-fx* count byte-width) start.bv) start.bv)))
      `(column:encoding.int:frame-of-reference
         (count                     ,count)
         (byte-size                 ,size.bv)
         (average-bytes-per-element ,(exact->inexact (/ size.bv count)))
         (bit-width                 ,(* byte-width 8))
         (z.min                     ,z.min))))
  (define ref
    (let ((go (lambda (byte-width n-ref)
                (lambda (i)
                  (let ((offset (unsafe-fx* i byte-width)))
                    (unsafe-fx+ (n-ref bv (unsafe-fx+ offset start.bv))
                                z.min))))))
      (case byte-width
        ((1)  (go 1 1-unrolled-unsafe-bytes-nat-ref))
        ((2)  (go 2 2-unrolled-unsafe-bytes-nat-ref))
        ((3)  (go 3 3-unrolled-unsafe-bytes-nat-ref))
        ((4)  (go 4 4-unrolled-unsafe-bytes-nat-ref))
        ((5)  (go 5 5-unrolled-unsafe-bytes-nat-ref))
        ((6)  (go 6 6-unrolled-unsafe-bytes-nat-ref))
        (else (go 7 7-unrolled-unsafe-bytes-nat-ref)))))
  (define (i=x? i x) (unsafe-fx= (ref i) x))
  (define (i<x? i x) (unsafe-fx< (ref i) x))
  (controller:column/array ref unsafe-fx= i=x? i<x? 'column:encoding.int:frame-of-reference count
                           describe))

(define (column:encoding.text:raw col.pos bv start.bv count)
  (let ((ref.pos (column-ref col.pos)))
    (define (describe)
      (let ((size.bv (- (ref.pos count) start.bv)))
        `(column:encoding.text:raw
           (count                     ,count)
           (byte-size                 ,size.bv)
           (average-bytes-per-element ,(exact->inexact (/ size.bv count)))
           (column.position           ,(column-describe col.pos)))))
    (define (ref i)
      (let* ((start (ref.pos i))
             (end   (ref.pos (unsafe-fx+ i 1)))
             (count (unsafe-fx- end start))
             (t     (make-bytes count)))
        (unsafe-bytes-copy! t 0 bv start end)
        t))
    (define (i=x? i x)
      (let* ((start (ref.pos i))
             (end   (ref.pos (unsafe-fx+ i 1)))
             (len.i (unsafe-fx- end start)))
        (and (unsafe-fx= (unsafe-bytes-length x) len.i)
             (let loop ((i start) (j 0))
               (or (unsafe-fx= start end)
                   (and (unsafe-fx= (unsafe-bytes-ref bv i) (unsafe-bytes-ref x j))
                        (loop (unsafe-fx+ i 1) (unsafe-fx+ j 1))))))))
    (define (i<x? i x)
      (let* ((start (ref.pos i))
             (len.i (unsafe-fx- (ref.pos (unsafe-fx+ i 1)) start))
             (len.x (unsafe-bytes-length x))
             (count (unsafe-fxmin len.i len.x)))
        (let loop ((i 0))
          (if (unsafe-fx= i count)
              (unsafe-fx< len.i len.x)
              (let ((b.i (unsafe-bytes-ref bv (unsafe-fx+ start i))) (b.x (unsafe-bytes-ref x i)))
                (or (unsafe-fx< b.i b.x)
                    (and (unsafe-fx= b.i b.x) (loop (unsafe-fx+ i 1)))))))))
    (controller:column/array ref unsafe-bytes=? i=x? i<x? 'column:encoding.text:raw count
                             describe)))

(define (column:encoding.int:single-value single-value count)
  (define (describe)
    `(column:encoding.int:single-value
       (count ,count)
       (value ,single-value)))
  (define (ref i) single-value)
  (define group             (group/single-value             single-value))
  (define group/key*        (group/key*/single-value        single-value unsafe-fx=))
  (define sorted-group/key* (sorted-group/key*/single-value single-value unsafe-fx< unsafe-fx=))
  (controller:column (controller:missing-method 'column:encoding.int:single-value)
                     count describe ref group group/key* sorted-group/key*))

(define (column:encoding.text:single-value single-value count)
  (define (describe)
    `(column:encoding.text:single-value
       (count  ,count)
       (length ,(bytes-length single-value))
       (value  ,single-value)))
  (define (ref i) single-value)
  (define group      (group/single-value      single-value))
  (define group/key* (group/key*/single-value single-value unsafe-bytes=?))
  (define sorted-group/key*
    (sorted-group/key*/single-value single-value unsafe-bytes<? unsafe-bytes=?))
  (controller:column (controller:missing-method 'column:encoding.text:single-value)
                     count describe ref group group/key* sorted-group/key*))

(define (column:encoding.int:delta-single-value z.start z.delta count)
  (define (describe)
    `(column:encoding.int:delta-single-value
       (count ,count)
       (start ,z.start)
       (delta ,z.delta)))
  (define (ref i) (unsafe-fx+ (unsafe-fx* z.delta i) z.start))
  (define (group start end)
    (if (unsafe-fx< start end)
        (lambda (yield!)
          (let loop ((i start) (z (ref start)))
            (when (unsafe-fx< i end)
              (let ((i.next (unsafe-fx+ i 1)))
                (yield! z i i.next)
                (loop i.next (unsafe-fx+ z z.delta))))))
        (lambda (yield!) (void))))
  (define (((group/key* key*) start end) yield!)
    (when (unsafe-fx< start end)
      (let ((len (unsafe-vector*-length key*)))
        (let loop ((i 0))
          (when (unsafe-fx< i len)
            (let* ((key (unsafe-vector*-ref key* i))
                   (n   (unsafe-fx- key z.start)))
              (when (unsafe-fx= (unsafe-fxremainder n z.delta) 0)
                (let ((code (unsafe-fxquotient n z.delta)))
                  (when (and (unsafe-fx<= start code) (unsafe-fx< code end))
                    (yield! key code (unsafe-fx+ code 1)))))
              (loop (unsafe-fx+ i 1))))))))
  (define (((sorted-group/key* key*) start end) yield!)
    (let ((len (unsafe-vector*-length key*)))
      (if (unsafe-fx< start end)
          (let loop ((i 0))
            (when (unsafe-fx< i len)
              (let* ((key (unsafe-vector*-ref key* i))
                     (n   (unsafe-fx- key z.start)))
                (let ((code (unsafe-fxquotient n z.delta)))
                  (cond ((unsafe-fx< code start) (yield! key start start))
                        ((unsafe-fx<= end code) (yield! key end end))
                        (else (yield! key code (if (unsafe-fx= (unsafe-fxremainder n z.delta) 0)
                                                   (unsafe-fx+ code 1)
                                                   code)))))
                (loop (unsafe-fx+ i 1)))))
          (let loop ((i 0))
            (when (unsafe-fx< i len)
              (yield! (unsafe-vector*-ref key* i) start start)
              (loop (unsafe-fx+ i 1)))))))
  (controller:column (controller:missing-method 'column:encoding.text:delta-single-value)
                     count describe ref group group/key* sorted-group/key*))

(define ((column:encoding.X:dictionary/X x<x? x=x? column-type-id.description)
         col.dict count.dict col.code count)
  (define (describe)
    `(,column-type-id.description
       (count             ,count)
       (column.dictionary ,(column-describe col.dict))
       (column.code       ,(column-describe col.code))))
  (let ((ref.code               (column-ref               col.code))
        (group.code             (column-group             col.code))
        (group/key*.code        (column-group/key*        col.code))
        (sorted-group/key*.dict (column-sorted-group/key* col.dict))
        (ref.dict               (column-ref               col.dict)))
    (define (ref i) (ref.dict (ref.code i)))
    (define (group start end) (group-map (group.code start end) ref.dict))
    (define (group/key* key*)
      (let ((i 0) (key*.encoded (make-vector (unsafe-vector*-length key*))))
        ((sorted-group/key*.dict key* 0 count.dict)
         (lambda (key start end)
           (when (unsafe-fx< start end)
             (unsafe-vector*-set! key*.encoded i start)
             (set! i (unsafe-fx+ i 1)))))
        (if (unsafe-fx< 0 i)
            (let ((group (group/key*.code (vector-copy key*.encoded 0 i))))
              (lambda (start end) (group-map (group start end) ref.dict)))
            (lambda (start end) (lambda (yield!) (void))))))
    (define (i<x? j x) (x<x? (ref j) x))
    (define (i=x? j x) (x=x? (ref j) x))
    (define sorted-group/key* (sorted-group/key*/i<x?&i=x? i<x? i=x?))
    (controller:column (controller:missing-method column-type-id.description)
                       count describe ref group group/key* sorted-group/key*)))
(define column:encoding.int:dictionary
  (column:encoding.X:dictionary/X unsafe-fx< unsafe-fx= 'column:encoding.int:dictionary))
(define column:encoding.text:dictionary
  (column:encoding.X:dictionary/X unsafe-bytes<? unsafe-bytes=? 'column:encoding.text:dictionary))

(define ((column:encoding.X:run-length/X column-type-id.description)
         col.pos col.run count.run count)
  (define (describe)
    `(,column-type-id.description
       (count           ,count)
       (column.position ,(column-describe col.pos))
       (column.run      ,(column-describe col.run))))
  (let ((ref.pos               (column-ref               col.pos))
        (ref.run               (column-ref               col.run))
        (group.run             (column-group             col.run))
        (group/key*.run        (column-group/key*        col.run))
        (sorted-group/key*.run (column-sorted-group/key* col.run)))
    (define (ref i) (ref.run (unsafe-bisect-skip 0 (unsafe-fx+ count.run 1)
                                                 (lambda (j) (unsafe-fx< (ref.pos j) i)))))
    (define ((group/group.run group.run) start end)
      (let* ((i.start (if (unsafe-fx= start 0)
                          0
                          (unsafe-fx-
                            (unsafe-bisect-skip 0 (unsafe-fx+ count.run 1)
                                                (lambda (i) (unsafe-fx<= (ref.pos i) start)))
                            1)))
             (i.end   (if (unsafe-fx= end count)
                          count.run
                          (unsafe-bisect-skip i.start (unsafe-fx+ count.run 1)
                                              (lambda (i) (unsafe-fx< (ref.pos i) end)))))
             (enum    (group.run i.start i.end)))
        (lambda (yield!)
          (enum (lambda (x start.run end.run) (yield! x (unsafe-fxmax (ref.pos start.run) start)
                                                      (unsafe-fxmin (ref.pos end.run) end)))))))
    (define group                    (group/group.run group.run))
    (define (group/key*        key*) (group/group.run (group/key*.run        key*)))
    (define (sorted-group/key* key*) (group/group.run (sorted-group/key*.run key*)))
    (controller:column (controller:missing-method column-type-id.description)
                       count describe ref group group/key* sorted-group/key*)))
(define (column:encoding.int:run-length col.pos col.run count.run count)
  (column:encoding.X:run-length/X 'column:encoding.int:run-length))
(define (column:encoding.text:run-length col.pos col.run count.run count)
  (column:encoding.X:run-length/X 'column:encoding.text:run-length))

(define (column:encoding.text:single-prefix prefix col.suffix count)
  (define (describe)
    `(column:encoding.text:single-prefix
       (count         ,count)
       (prefix        ,prefix)
       (column.suffix ,(column-describe col.suffix))))
  (let ((len.prefix               (unsafe-bytes-length prefix))
        (ref.suffix               (column-ref col.suffix))
        (group.suffix             (column-group col.suffix))
        (group/key*.suffix        (column-group/key* col.suffix))
        (sorted-group/key*.suffix (column-sorted-group/key* col.suffix)))
    (define (decode suffix)
      (let* ((len.suffix (unsafe-bytes-length suffix))
             (t          (make-bytes (unsafe-fx+ len.prefix len.suffix))))
        (unsafe-bytes-copy! t 0 prefix 0 len.prefix)
        (unsafe-bytes-copy! t len.prefix suffix 0 len.suffix)
        t))
    (define (encode* key*)
      (let* ((len          (unsafe-vector*-length key*))
             (key*.encoded (make-vector len))
             (len          (let loop ((i 0) (j 0))
                             (if (unsafe-fx< i len)
                                 (let ((key (unsafe-vector*-ref key* i)))
                                   (if (unsafe-bytes-prefix? key prefix)
                                       (begin (unsafe-vector*-set!
                                                key*.encoded j (subbytes key len.prefix))
                                              (loop (unsafe-fx+ i 1) (unsafe-fx+ j 1)))
                                       (loop (unsafe-fx+ i 1) j)))
                                 j))))
        (vector-copy key*.encoded 0 len)))
    (define (ref i) (decode (ref.suffix i)))
    (define (group start end) (group-map (group.suffix start end) decode))
    (define (group/key* key*) (let ((group (group/key*.suffix (encode* key*))))
                                (lambda (start end) (group-map (group start end) decode))))
    (define (sorted-group/key* key*)
      (let* ((len          (unsafe-vector*-length key*))
             (key*.encoded (encode* key*))
             (group        (sorted-group/key*.suffix key*.encoded)))
        (lambda (start end)
          (let ((enum (group-map (group start end) decode)))
            (lambda (yield!)
              (let loop ((i 0))
                (when (unsafe-fx< i len)
                  (let ((key (unsafe-vector*-ref key* i)))
                    (when (unsafe-bytes<? key prefix)
                      (yield! key start start)
                      (loop (unsafe-fx+ i 1))))))
              (enum yield!)
              (let loop ((i (unsafe-fx- len 1)))
                (when (unsafe-fx<= 0 i)
                  (let ((key (unsafe-vector*-ref key* i)))
                    (when (and (unsafe-bytes<? prefix key)
                               (not (unsafe-bytes-prefix? key prefix)))
                      (yield! key end end)
                      (loop (unsafe-fx- i 1)))))))))))
    (controller:column (controller:missing-method 'column:encoding.text:single-prefix)
                       count describe ref group group/key* sorted-group/key*)))

(define (column:encoding.text:multi-prefix col.prefix count.prefix col.suffix count)
  (define (describe)
    `(column:encoding.text:multi-prefix
       (count         ,count)
       (column.prefix ,(column-describe col.prefix))
       (column.suffix ,(column-describe col.suffix))))
  (let ((byte-width.code (nat-min-byte-width count.prefix))
        (ref.prefix      (column-ref   col.prefix))
        (ref.suffix      (column-ref   col.suffix))
        (group.suffix    (column-group col.suffix)))
    (define decode
      (let ((go (lambda (byte-width.code n-ref)
                  (lambda (suffix)
                    (let* ((prefix     (ref.prefix (n-ref suffix 0)))
                           (len.prefix (unsafe-bytes-length prefix))
                           (len.suffix (unsafe-bytes-length suffix))
                           (t          (make-bytes
                                         (unsafe-fx+ (unsafe-fx- len.suffix byte-width.code)
                                                     len.prefix))))
                      (unsafe-bytes-copy! t 0          prefix 0               len.prefix)
                      (unsafe-bytes-copy! t len.prefix suffix byte-width.code len.suffix)
                      t)))))
        (case byte-width.code
          ((1)  (go 1 1-unrolled-unsafe-bytes-nat-ref))
          ((2)  (go 2 2-unrolled-unsafe-bytes-nat-ref))
          ((3)  (go 3 3-unrolled-unsafe-bytes-nat-ref))
          ((4)  (go 4 4-unrolled-unsafe-bytes-nat-ref))
          ((5)  (go 5 5-unrolled-unsafe-bytes-nat-ref))
          ((6)  (go 6 6-unrolled-unsafe-bytes-nat-ref))
          (else (go 7 7-unrolled-unsafe-bytes-nat-ref)))))
    (define (ref i) (decode (ref.suffix i)))
    (define (group start end) (group-map (group.suffix start end) decode))
    (define group/key* (group/key*/group group unsafe-bytes=?))
    (define (i<x? j x) (unsafe-bytes<? (ref j) x))
    (define (i=x? j x) (unsafe-bytes=? (ref j) x))
    (define sorted-group/key* (sorted-group/key*/i<x?&i=x? i<x? i=x?))
    (controller:column (controller:missing-method 'column:encoding.text:multi-prefix)
                       count describe ref group group/key* sorted-group/key*)))

(define ((column:ref/class-name class-name x<x? x=x?) ref count)
  (define (describe) `(,class-name (count ,count)))
  (define (i=x? i x) (x=x? (ref i) x))
  (define (i<x? i x) (x<x? (ref i) x))
  (controller:column/array ref x=x? i=x? i<x? class-name count describe))
(define column:ref.int  (column:ref/class-name 'column:ref.int unsafe-fx< unsafe-fx=))
(define column:ref.text (column:ref/class-name 'column:ref.text unsafe-bytes<? unsafe-bytes=?))
(define (column:vector/class-name class-name x<x? x=x?)
  (let ((make-col (column:ref/class-name class-name x<x? x=x?)))
    (lambda (x*) (make-col (lambda (i) (unsafe-vector*-ref x* i)) (unsafe-vector*-length x*)))))
(define column:vector.int  (column:vector/class-name 'column:vector.int unsafe-fx< unsafe-fx=))
(define column:vector.text (column:vector/class-name 'column:vector.text unsafe-bytes<? unsafe-bytes=?))

;(define (int-segment-encode!.nat/byte-width byte-width bv pos n* start end)
;  )
;(define (int-segment-encode!.nat/max n.max bv pos n* start end)
;  )
